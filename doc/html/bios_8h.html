<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TinyOS-3: bios.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TinyOS-3
   &#160;<span id="projectnumber">rev.2016</span>
   </div>
   <div id="projectbrief">A multicore Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bios.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Virtual Machine API.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;ucontext.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bios.h:</div>
<div class="dyncontent">
<div class="center"><img src="bios_8h__incl.png" border="0" usemap="#bios_8h" alt=""/></div>
<map name="bios_8h" id="bios_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="bios_8h__dep__incl.png" border="0" usemap="#bios_8hdep" alt=""/></div>
<map name="bios_8hdep" id="bios_8hdep">
<area shape="rect" id="node2" href="kernel__dev_8h.html" title="Device management. " alt="" coords="289,80,385,107"/>
<area shape="rect" id="node8" href="kernel__init_8c_source.html" title="kernel_init.c" alt="" coords="173,229,265,256"/>
<area shape="rect" id="node15" href="kernel__sched_8h.html" title="TinyOS kernel: The Scheduler API. " alt="" coords="940,80,1051,107"/>
<area shape="rect" id="node21" href="kernel__sys_8h_source.html" title="kernel_sys.h" alt="" coords="1097,80,1193,107"/>
<area shape="rect" id="node22" href="unit__testing_8h.html" title="A library for coding and running unit tests. " alt="" coords="1217,80,1317,107"/>
<area shape="rect" id="node24" href="tinyos__shell_8c_source.html" title="tinyos_shell.c" alt="" coords="1341,80,1444,107"/>
<area shape="rect" id="node3" href="kernel__streams_8h.html" title="Support for I/O streams. " alt="" coords="570,155,693,181"/>
<area shape="rect" id="node5" href="kernel__dev_8c_source.html" title="kernel_dev.c" alt="" coords="789,229,885,256"/>
<area shape="rect" id="node9" href="kernel__pipe_8c_source.html" title="kernel_pipe.c" alt="" coords="290,229,389,256"/>
<area shape="rect" id="node10" href="kernel__socket_8c_source.html" title="kernel_socket.c" alt="" coords="369,304,483,331"/>
<area shape="rect" id="node13" href="kernel__pipe_8h_source.html" title="kernel_pipe.h" alt="" coords="245,155,343,181"/>
<area shape="rect" id="node14" href="kernel__socket_8h_source.html" title="kernel_socket.h" alt="" coords="34,229,149,256"/>
<area shape="rect" id="node4" href="console_8c_source.html" title="console.c" alt="" coords="464,229,543,256"/>
<area shape="rect" id="node6" href="kernel__info_8h_source.html" title="kernel_info.h" alt="" coords="669,229,765,256"/>
<area shape="rect" id="node7" href="kernel__proc_8c_source.html" title="kernel_proc.c" alt="" coords="843,304,943,331"/>
<area shape="rect" id="node11" href="kernel__streams_8c_source.html" title="kernel_streams.c" alt="" coords="909,229,1031,256"/>
<area shape="rect" id="node12" href="kernel__threads_8c_source.html" title="kernel_threads.c" alt="" coords="1107,229,1225,256"/>
<area shape="rect" id="node16" href="kernel__cc_8c.html" title="The implementation for concurrency control . " alt="" coords="1301,229,1391,256"/>
<area shape="rect" id="node17" href="kernel__proc_8h.html" title="The process table and process management. " alt="" coords="945,155,1045,181"/>
<area shape="rect" id="node18" href="kernel__sched_8c_source.html" title="kernel_sched.c" alt="" coords="1415,229,1525,256"/>
<area shape="rect" id="node19" href="kernel__cc_8h.html" title="Concurrency and preemption control API. " alt="" coords="1121,155,1211,181"/>
<area shape="rect" id="node20" href="kernel__sys_8c_source.html" title="kernel_sys.c" alt="" coords="1601,229,1697,256"/>
<area shape="rect" id="node23" href="test__example_8c_source.html" title="test_example.c" alt="" coords="1388,155,1499,181"/>
</map>
</div>
</div>
<p><a href="bios_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a009855593b59738d24dbfc236edb3b14"><td class="memItemLeft" align="right" valign="top"><a id="a009855593b59738d24dbfc236edb3b14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a009855593b59738d24dbfc236edb3b14">MAX_CORES</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:a009855593b59738d24dbfc236edb3b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of cores for a virtual machine. <br /></td></tr>
<tr class="separator:a009855593b59738d24dbfc236edb3b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7d162c7c35103b42768ff4a5c73905"><td class="memItemLeft" align="right" valign="top"><a id="a4e7d162c7c35103b42768ff4a5c73905"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a4e7d162c7c35103b42768ff4a5c73905">MAX_TERMINALS</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a4e7d162c7c35103b42768ff4a5c73905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of terminals for a virtual machine. <br /></td></tr>
<tr class="separator:a4e7d162c7c35103b42768ff4a5c73905"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a11aeb47c6c66d331acd12556d0d4aedc"><td class="memItemLeft" align="right" valign="top"><a id="a11aeb47c6c66d331acd12556d0d4aedc"></a>
typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a11aeb47c6c66d331acd12556d0d4aedc">interrupt_handler</a>()</td></tr>
<tr class="memdesc:a11aeb47c6c66d331acd12556d0d4aedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signature type of interrupt handlers. <br /></td></tr>
<tr class="separator:a11aeb47c6c66d331acd12556d0d4aedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d486213aa4f744f497959af6917e2a0"><td class="memItemLeft" align="right" valign="top"><a id="a5d486213aa4f744f497959af6917e2a0"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>sig_atomic_t</b></td></tr>
<tr class="separator:a5d486213aa4f744f497959af6917e2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memItemLeft" align="right" valign="top"><a id="a91ad9478d81a7aaf2593e8d9c3d06a14"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td></tr>
<tr class="memdesc:a91ad9478d81a7aaf2593e8d9c3d06a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper declaration. <br /></td></tr>
<tr class="separator:a91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7291e5cd742fb9bc6d4aaa0d51bd0ee"><td class="memItemLeft" align="right" valign="top"><a id="ae7291e5cd742fb9bc6d4aaa0d51bd0ee"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#ae7291e5cd742fb9bc6d4aaa0d51bd0ee">TimerDuration</a></td></tr>
<tr class="memdesc:ae7291e5cd742fb9bc6d4aaa0d51bd0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for time intervals measured in microseconds. <br /></td></tr>
<tr class="separator:ae7291e5cd742fb9bc6d4aaa0d51bd0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d92c1d2b682bfedd88e238b6bf2fb22"><td class="memItemLeft" align="right" valign="top"><a id="a9d92c1d2b682bfedd88e238b6bf2fb22"></a>
typedef enum <a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaa">Interrupt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a9d92c1d2b682bfedd88e238b6bf2fb22">Interrupt</a></td></tr>
<tr class="memdesc:a9d92c1d2b682bfedd88e238b6bf2fb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interrupts supported by the CPU. <br /></td></tr>
<tr class="separator:a9d92c1d2b682bfedd88e238b6bf2fb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6067c1395a75fc3e17f1ea6353065b54"><td class="memItemLeft" align="right" valign="top"><a id="a6067c1395a75fc3e17f1ea6353065b54"></a>
typedef ucontext_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a6067c1395a75fc3e17f1ea6353065b54">cpu_context_t</a></td></tr>
<tr class="memdesc:a6067c1395a75fc3e17f1ea6353065b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for saving CPU context into. <br /></td></tr>
<tr class="separator:a6067c1395a75fc3e17f1ea6353065b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a137af7bce5ff764f5c0aa4550086deaa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaa">Interrupt</a> { <br />
&#160;&#160;<a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaaab4019255561cb4b48789d55c079e1709">ICI</a>, 
<a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaaac4212312865bd8ac6810b9651d9e80df">ALARM</a>, 
<a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaaa2e06ea796d072595be1770c601e78206">SERIAL_RX_READY</a>, 
<a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaaad168539d997c69c61da9c1f5f3187878">SERIAL_TX_READY</a>, 
<br />
&#160;&#160;<b>maximum_interrupt_no</b>
<br />
 }<tr class="memdesc:a137af7bce5ff764f5c0aa4550086deaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interrupts supported by the CPU.  <a href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaa">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a137af7bce5ff764f5c0aa4550086deaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3474751482bc2a9a40597f66fe35f630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a3474751482bc2a9a40597f66fe35f630">vm_boot</a> (<a class="el" href="bios_8h.html#a11aeb47c6c66d331acd12556d0d4aedc">interrupt_handler</a> bootfunc, <a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cores, <a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> serialno)</td></tr>
<tr class="memdesc:a3474751482bc2a9a40597f66fe35f630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot a CPU with the given number of cores and boot function.  <a href="#a3474751482bc2a9a40597f66fe35f630">More...</a><br /></td></tr>
<tr class="separator:a3474751482bc2a9a40597f66fe35f630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02a29e5c8a1f4d68413eea0aaa09fba"><td class="memItemLeft" align="right" valign="top"><a id="aa02a29e5c8a1f4d68413eea0aaa09fba"></a>
<a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#aa02a29e5c8a1f4d68413eea0aaa09fba">cpu_cores</a> ()</td></tr>
<tr class="memdesc:aa02a29e5c8a1f4d68413eea0aaa09fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of cores. <br /></td></tr>
<tr class="separator:aa02a29e5c8a1f4d68413eea0aaa09fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f96f6027a2276735b4a221a56ed786"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#ab8f96f6027a2276735b4a221a56ed786">cpu_core_barrier_sync</a> ()</td></tr>
<tr class="memdesc:ab8f96f6027a2276735b4a221a56ed786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Barrier synchronization for all cores.  <a href="#ab8f96f6027a2276735b4a221a56ed786">More...</a><br /></td></tr>
<tr class="separator:ab8f96f6027a2276735b4a221a56ed786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719b0f9f8854d21436c96931ba1caf59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a719b0f9f8854d21436c96931ba1caf59">cpu_ici</a> (<a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> core)</td></tr>
<tr class="memdesc:a719b0f9f8854d21436c96931ba1caf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an ICI interrupt to the given core.  <a href="#a719b0f9f8854d21436c96931ba1caf59">More...</a><br /></td></tr>
<tr class="separator:a719b0f9f8854d21436c96931ba1caf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf5c5e80f04d98362346e6ec770022d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a0cf5c5e80f04d98362346e6ec770022d">cpu_interrupt_handler</a> (<a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaa">Interrupt</a> interrupt, <a class="el" href="bios_8h.html#a11aeb47c6c66d331acd12556d0d4aedc">interrupt_handler</a> handler)</td></tr>
<tr class="memdesc:a0cf5c5e80f04d98362346e6ec770022d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an interrupt handler for this core.  <a href="#a0cf5c5e80f04d98362346e6ec770022d">More...</a><br /></td></tr>
<tr class="separator:a0cf5c5e80f04d98362346e6ec770022d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2be31ceb56ec6919d4d25fe4b2da0c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#ab2be31ceb56ec6919d4d25fe4b2da0c8">cpu_disable_interrupts</a> ()</td></tr>
<tr class="memdesc:ab2be31ceb56ec6919d4d25fe4b2da0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable interrupts for this core.  <a href="#ab2be31ceb56ec6919d4d25fe4b2da0c8">More...</a><br /></td></tr>
<tr class="separator:ab2be31ceb56ec6919d4d25fe4b2da0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10055a90cf57a2a22fa9193922f9f2a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a10055a90cf57a2a22fa9193922f9f2a8">cpu_enable_interrupts</a> ()</td></tr>
<tr class="memdesc:a10055a90cf57a2a22fa9193922f9f2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupts for this core.  <a href="#a10055a90cf57a2a22fa9193922f9f2a8">More...</a><br /></td></tr>
<tr class="separator:a10055a90cf57a2a22fa9193922f9f2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2c9a3aea40c8eeaa723ee35caace06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a3e2c9a3aea40c8eeaa723ee35caace06">cpu_core_halt</a> ()</td></tr>
<tr class="memdesc:a3e2c9a3aea40c8eeaa723ee35caace06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt the core until an interrupt arrives.  <a href="#a3e2c9a3aea40c8eeaa723ee35caace06">More...</a><br /></td></tr>
<tr class="separator:a3e2c9a3aea40c8eeaa723ee35caace06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9191a31f24c07b8282a3c8edbba24ee0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a9191a31f24c07b8282a3c8edbba24ee0">cpu_core_restart</a> (<a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> c)</td></tr>
<tr class="memdesc:a9191a31f24c07b8282a3c8edbba24ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart the given core.  <a href="#a9191a31f24c07b8282a3c8edbba24ee0">More...</a><br /></td></tr>
<tr class="separator:a9191a31f24c07b8282a3c8edbba24ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eeccd43040cc43ac977f649d639a3e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a7eeccd43040cc43ac977f649d639a3e9">cpu_core_restart_one</a> ()</td></tr>
<tr class="memdesc:a7eeccd43040cc43ac977f649d639a3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart some halted core.  <a href="#a7eeccd43040cc43ac977f649d639a3e9">More...</a><br /></td></tr>
<tr class="separator:a7eeccd43040cc43ac977f649d639a3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82b1a876663da26cbf511bcfb06404d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#aa82b1a876663da26cbf511bcfb06404d">cpu_core_restart_all</a> ()</td></tr>
<tr class="memdesc:aa82b1a876663da26cbf511bcfb06404d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal all halted cores to restart.  <a href="#aa82b1a876663da26cbf511bcfb06404d">More...</a><br /></td></tr>
<tr class="separator:aa82b1a876663da26cbf511bcfb06404d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825ac4a4bcf2ef8d3c9bb48d5434c161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a825ac4a4bcf2ef8d3c9bb48d5434c161">cpu_initialize_context</a> (<a class="el" href="bios_8h.html#a6067c1395a75fc3e17f1ea6353065b54">cpu_context_t</a> *ctx, void *ss_sp, size_t ss_size, void(*func)())</td></tr>
<tr class="memdesc:a825ac4a4bcf2ef8d3c9bb48d5434c161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a CPU context for a new thread.  <a href="#a825ac4a4bcf2ef8d3c9bb48d5434c161">More...</a><br /></td></tr>
<tr class="separator:a825ac4a4bcf2ef8d3c9bb48d5434c161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a3870d56e6867224909cf226c2e90a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a78a3870d56e6867224909cf226c2e90a">cpu_swap_context</a> (<a class="el" href="bios_8h.html#a6067c1395a75fc3e17f1ea6353065b54">cpu_context_t</a> *oldctx, <a class="el" href="bios_8h.html#a6067c1395a75fc3e17f1ea6353065b54">cpu_context_t</a> *newctx)</td></tr>
<tr class="memdesc:a78a3870d56e6867224909cf226c2e90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch the CPU context.  <a href="#a78a3870d56e6867224909cf226c2e90a">More...</a><br /></td></tr>
<tr class="separator:a78a3870d56e6867224909cf226c2e90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f7a35679bdda42fff3da6ae6e5664b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bios_8h.html#ae7291e5cd742fb9bc6d4aaa0d51bd0ee">TimerDuration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a01f7a35679bdda42fff3da6ae6e5664b">bios_set_timer</a> (<a class="el" href="bios_8h.html#ae7291e5cd742fb9bc6d4aaa0d51bd0ee">TimerDuration</a> usec)</td></tr>
<tr class="memdesc:a01f7a35679bdda42fff3da6ae6e5664b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the core timer to the specified interval.  <a href="#a01f7a35679bdda42fff3da6ae6e5664b">More...</a><br /></td></tr>
<tr class="separator:a01f7a35679bdda42fff3da6ae6e5664b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27768c037d72b51415b836bd93196df2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bios_8h.html#ae7291e5cd742fb9bc6d4aaa0d51bd0ee">TimerDuration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a27768c037d72b51415b836bd93196df2">bios_cancel_timer</a> ()</td></tr>
<tr class="memdesc:a27768c037d72b51415b836bd93196df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the current activated timer, if any.  <a href="#a27768c037d72b51415b836bd93196df2">More...</a><br /></td></tr>
<tr class="separator:a27768c037d72b51415b836bd93196df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78addcd72c31fb32d46cc51fe01a86b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bios_8h.html#ae7291e5cd742fb9bc6d4aaa0d51bd0ee">TimerDuration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a78addcd72c31fb32d46cc51fe01a86b4">bios_clock</a> ()</td></tr>
<tr class="memdesc:a78addcd72c31fb32d46cc51fe01a86b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current time from the hardware clock.  <a href="#a78addcd72c31fb32d46cc51fe01a86b4">More...</a><br /></td></tr>
<tr class="separator:a78addcd72c31fb32d46cc51fe01a86b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69405820033d3f2e8033af258f47ea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#af69405820033d3f2e8033af258f47ea2">bios_serial_ports</a> ()</td></tr>
<tr class="memdesc:af69405820033d3f2e8033af258f47ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of serial ports/terminals.  <a href="#af69405820033d3f2e8033af258f47ea2">More...</a><br /></td></tr>
<tr class="separator:af69405820033d3f2e8033af258f47ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9df4f1db5a1d99720f327668726e2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a3d9df4f1db5a1d99720f327668726e2b">bios_serial_interrupt_core</a> (<a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> serial, <a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaa">Interrupt</a> intno, <a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> core)</td></tr>
<tr class="memdesc:a3d9df4f1db5a1d99720f327668726e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a core to interrupts from a specific serial device.  <a href="#a3d9df4f1db5a1d99720f327668726e2b">More...</a><br /></td></tr>
<tr class="separator:a3d9df4f1db5a1d99720f327668726e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ebe8b1d424c0ef473db751f7b79fbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a04ebe8b1d424c0ef473db751f7b79fbb">bios_read_serial</a> (<a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> serial, char *ptr)</td></tr>
<tr class="memdesc:a04ebe8b1d424c0ef473db751f7b79fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from a serial port.  <a href="#a04ebe8b1d424c0ef473db751f7b79fbb">More...</a><br /></td></tr>
<tr class="separator:a04ebe8b1d424c0ef473db751f7b79fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bde2ebd5f9d86c0085aacaa5e5d287"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#a97bde2ebd5f9d86c0085aacaa5e5d287">bios_write_serial</a> (<a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> serial, char value)</td></tr>
<tr class="memdesc:a97bde2ebd5f9d86c0085aacaa5e5d287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte to a serial port.  <a href="#a97bde2ebd5f9d86c0085aacaa5e5d287">More...</a><br /></td></tr>
<tr class="separator:a97bde2ebd5f9d86c0085aacaa5e5d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abac58ced7d51f54f2318b326bc991933"><td class="memItemLeft" align="right" valign="top"><a id="abac58ced7d51f54f2318b326bc991933"></a>
_Thread_local <a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bios_8h.html#abac58ced7d51f54f2318b326bc991933">cpu_core_id</a></td></tr>
<tr class="memdesc:abac58ced7d51f54f2318b326bc991933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the id of the current core. <br /></td></tr>
<tr class="separator:abac58ced7d51f54f2318b326bc991933"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Virtual Machine API. </p>
<p>This file contains the API for a virtual machine (simulated computer) which we will refer to as VM. This VM is used to implement tinyos3 on.</p>
<p>The VM has a multicore CPU and peripherals.</p>
<p>A simulation starts by calling function <code>vm_boot</code>. The description of the VM (currently, the number of simulated cores and the number of terminal devices), and also the initial function executed by each core at boot time, are given as arguments.</p>
<p>The VM (virtual) hardware is controlled by a BIOS (Basic I/O System) through the BIOS API. We now describe the concepts of the BIOS in detail.</p>
<h2>CPU </h2>
<p>A CPU has 1 or more cores. Each core executes independently of each other. Variable cpu_core_id contains the id number of the current core.</p>
<h2>Interrupts </h2>
<p>Each CPU core has its own interrupt vector&mdash;it can set its own interrupt handlers, independently of other cores. Setting an interrupt handler to <code>NULL</code> (the default), ignores the interrupt for this core.</p>
<ul>
<li>When an interrupt handler executes, interrupts are initially disabled.</li>
<li>Interrupts can also be enabled and disabled programmatically.</li>
<li>If an interrupt is raised while interrupts are disabled, it will be marked as raised and the interrupt handler (if non-NULL) will be called as soon as interrupts are re-enabled.</li>
<li>The <b>ICI</b> (Inter-Core Interrupt) interrupt can be sent from one core to another (or to itself!).</li>
</ul>
<h2>Peripherals </h2>
<p>The peripherals are managed via the 'bios_...' functions.</p>
<p>There are two types of simulated peripherals: <em>timers</em> and <em>serial ports</em> (connected to terminals). Each type of peripheral is documented below.</p>
<h2>Timers </h2>
<p>Each simulated core has its own timer. A timer can be activated by initializing it with some time interval. When the timer expires, the ALARM interrupt is raised for the core.</p>
<h2>Serial ports </h2>
<p>The virtual machine has a number of serial ports connected to terminals.</p>
<p>Each serial port/terminal can support reading and writing of single bytes. The reads return keyboard input, whereas the writes send characters to display on the screen.</p>
<p>Terminals are numbered from 0, up to <code>MAX_TERMINALS-1</code>.</p>
<p>Implementation-wise, for each terminal/serial port, two Unix named pipes must exist in the current directory: one named con \( N \) and one named kbd \( N \), where \( N \) is the number of the serial port. For example, if the computer has 2 serial ports, the following named pipes must be defined in the current directory at runtime: con0 kbd0 con1 kbd1</p>
<p>Also, program 'terminal' must be executed twice (in two different windows):</p>
<p>./terminal 0</p>
<p>./terminal 1</p>
<p>Data can be read from a serial port, one byte at a time. A read may fail if the device is not-ready to perform the operation. On a device which is ready, the read will succeed. When a non-ready device becomes ready, a <code>SERIAL_RX_READY</code> interrupt is raised.</p>
<p>Data can be written to a serial port, one byte at a time. A write may fail if the device is not-ready to perform the operation. On a device which is ready, the write will succeed. When a non-ready device becomes ready, a <code>SERIAL_TX_READY</code> interrupt is raised.</p>
<p>Also, each interrupt is sent if the serial device timeouts (is inactive for about 300 msec). </p>

<p class="definition">Definition in file <a class="el" href="bios_8h_source.html">bios.h</a>.</p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a137af7bce5ff764f5c0aa4550086deaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137af7bce5ff764f5c0aa4550086deaa">&#9670;&nbsp;</a></span>Interrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaa">Interrupt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The interrupts supported by the CPU. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a137af7bce5ff764f5c0aa4550086deaaab4019255561cb4b48789d55c079e1709"></a>ICI&#160;</td><td class="fielddoc"><p>Raised by some core, via <a class="el" href="bios_8h.html#a719b0f9f8854d21436c96931ba1caf59" title="Raise an ICI interrupt to the given core. ">cpu_ici()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a137af7bce5ff764f5c0aa4550086deaaac4212312865bd8ac6810b9651d9e80df"></a>ALARM&#160;</td><td class="fielddoc"><p>Raised when the core's timer expires. </p>
</td></tr>
<tr><td class="fieldname"><a id="a137af7bce5ff764f5c0aa4550086deaaa2e06ea796d072595be1770c601e78206"></a>SERIAL_RX_READY&#160;</td><td class="fielddoc"><p>Raised when data is available for reading from a serial port </p>
</td></tr>
<tr><td class="fieldname"><a id="a137af7bce5ff764f5c0aa4550086deaaad168539d997c69c61da9c1f5f3187878"></a>SERIAL_TX_READY&#160;</td><td class="fielddoc"><p>Raised when a serial port is ready to accept data </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="bios_8h_source.html#l00118">118</a> of file <a class="el" href="bios_8h_source.html">bios.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a27768c037d72b51415b836bd93196df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27768c037d72b51415b836bd93196df2">&#9670;&nbsp;</a></span>bios_cancel_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bios_8h.html#ae7291e5cd742fb9bc6d4aaa0d51bd0ee">TimerDuration</a> bios_cancel_timer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel the current activated timer, if any. </p>
<p>This can be called even if the timer is not already activated. This call is equivalent to bios_set_timer(0).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bios_8h.html#a01f7a35679bdda42fff3da6ae6e5664b" title="Reset the core timer to the specified interval. ">bios_set_timer</a> </dd></dl>

</div>
</div>
<a id="a78addcd72c31fb32d46cc51fe01a86b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78addcd72c31fb32d46cc51fe01a86b4">&#9670;&nbsp;</a></span>bios_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bios_8h.html#ae7291e5cd742fb9bc6d4aaa0d51bd0ee">TimerDuration</a> bios_clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current time from the hardware clock. </p>
<p>This function returns a real-time clock value, in usec. The value of the clock is 10 times the number of seconds since the epoch.</p>
<p>The resolution of the clock is very low, currently around 100 msec. Therefore, it is inappropriate for any type of precise timing. </p>

</div>
</div>
<a id="a04ebe8b1d424c0ef473db751f7b79fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ebe8b1d424c0ef473db751f7b79fbb">&#9670;&nbsp;</a></span>bios_read_serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bios_read_serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a byte from a serial port. </p>
<p>Try to read a byte from serial port <code>serial</code> and store it into the location pointed by <code>ptr</code>. If the operation succeds, 1 is returned. If not, 0 is returned. The operation may not succeed, if the terminal connected to the serial port has not sent any data.</p>
<p>If this operation returns 0, a <code>SERIAL_RX_READY</code> interrupt will be raised when data is ready to be received, but the contents of <code>*ptr</code> will not be touched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>the serial device to read from </td></tr>
    <tr><td class="paramname">ptr</td><td>the location in which to store the read byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a integer designating success (non-zero) or failure (zero) </dd></dl>

</div>
</div>
<a id="a3d9df4f1db5a1d99720f327668726e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9df4f1db5a1d99720f327668726e2b">&#9670;&nbsp;</a></span>bios_serial_interrupt_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bios_serial_interrupt_core </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaa">Interrupt</a>&#160;</td>
          <td class="paramname"><em>intno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a core to interrupts from a specific serial device. </p>
<p>Make interrupts of type <code>intno</code> for serial port port <code>serial</code> be sent to <code>core</code>. By default, initially all interrupts are sent to core 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>the serial device whose interrupt is assigned, it must be greater of equal to <code>0</code> and less than <code><a class="el" href="bios_8h.html#af69405820033d3f2e8033af258f47ea2" title="Return the number of serial ports/terminals. ">bios_serial_ports()</a></code>. </td></tr>
    <tr><td class="paramname">intno</td><td>the interrupt to assign (one of <code>SERIAL_RX_READY</code> and <code>SERIAL_TX_READY</code>) </td></tr>
    <tr><td class="paramname">core</td><td>th </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69405820033d3f2e8033af258f47ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69405820033d3f2e8033af258f47ea2">&#9670;&nbsp;</a></span>bios_serial_ports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> bios_serial_ports </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of serial ports/terminals. </p>
<p>This is the number specified at the initialization of the VM. </p>

</div>
</div>
<a id="a01f7a35679bdda42fff3da6ae6e5664b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f7a35679bdda42fff3da6ae6e5664b">&#9670;&nbsp;</a></span>bios_set_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bios_8h.html#ae7291e5cd742fb9bc6d4aaa0d51bd0ee">TimerDuration</a> bios_set_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bios_8h.html#ae7291e5cd742fb9bc6d4aaa0d51bd0ee">TimerDuration</a>&#160;</td>
          <td class="paramname"><em>usec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the core timer to the specified interval. </p>
<p>The interval for the timer is given in microseconds, but the accuracy of the alarm is much coarser, to the order of 10 msec (that is, 10,000 microseconds). After the interval expires, the core receives an ALARM interrupt.</p>
<p>This function can be called even if the timer is already activated; in this case, the previous timer countdown is canceled and the timer resets to the new value.</p>
<p>If <code>usec</code> is specified as 0, any existing timer count is canceled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usec</td><td>the timer countdown interval in microseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time remaining interval since the last call </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bios_8h.html#a27768c037d72b51415b836bd93196df2" title="Cancel the current activated timer, if any. ">bios_cancel_timer</a> </dd></dl>

</div>
</div>
<a id="a97bde2ebd5f9d86c0085aacaa5e5d287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bde2ebd5f9d86c0085aacaa5e5d287">&#9670;&nbsp;</a></span>bios_write_serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bios_write_serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a byte to a serial port. </p>
<p>Try to write byte <code>value</code> to serial port <code>serial</code>. If the operation succeds, 1 is returned. If not, 0 is returned.</p>
<p>If this operation returns 0, a <code>SERIAL_TX_READY</code> interrupt will be raised when the device is ready to accept data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>the serial device to write to </td></tr>
    <tr><td class="paramname">value</td><td>the value to send to the serial device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a integer designating success (non-zero) or failure (zero) </dd></dl>

</div>
</div>
<a id="ab8f96f6027a2276735b4a221a56ed786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f96f6027a2276735b4a221a56ed786">&#9670;&nbsp;</a></span>cpu_core_barrier_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_core_barrier_sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Barrier synchronization for all cores. </p>
<p>Each core calling this function stops, until all cores have called it. Then, all cores proceed.</p>
<p>This is mostly useful when the machine boots the operating system, or at shutdown. </p>

</div>
</div>
<a id="a3e2c9a3aea40c8eeaa723ee35caace06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2c9a3aea40c8eeaa723ee35caace06">&#9670;&nbsp;</a></span>cpu_core_halt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_core_halt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt the core until an interrupt arrives. </p>
<p>This function will block the core on which it is called, until an interrupt arrives for the core.</p>
<p>This function is useful when a core becomes idle. An idle core does not consume simulation resources (in particular CPU time). </p>

</div>
</div>
<a id="a9191a31f24c07b8282a3c8edbba24ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9191a31f24c07b8282a3c8edbba24ee0">&#9670;&nbsp;</a></span>cpu_core_restart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_core_restart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart the given core. </p>
<p>This call will restart the given core, if it was halted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the core to restart </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa82b1a876663da26cbf511bcfb06404d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82b1a876663da26cbf511bcfb06404d">&#9670;&nbsp;</a></span>cpu_core_restart_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_core_restart_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal all halted cores to restart. </p>
<p>When this function is called, all halted cores will be restarted. </p>

</div>
</div>
<a id="a7eeccd43040cc43ac977f649d639a3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eeccd43040cc43ac977f649d639a3e9">&#9670;&nbsp;</a></span>cpu_core_restart_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_core_restart_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart some halted core. </p>
<p>This call will restart some halted core, if at least one exists. </p>

</div>
</div>
<a id="ab2be31ceb56ec6919d4d25fe4b2da0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2be31ceb56ec6919d4d25fe4b2da0c8">&#9670;&nbsp;</a></span>cpu_disable_interrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_disable_interrupts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable interrupts for this core. </p>
<p>If an interrupt arrives while interrupts are disabled, it will be marked as <em>pending</em> and will be raised when interrupts are re-enabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bios_8h.html#a10055a90cf57a2a22fa9193922f9f2a8" title="Enable interrupts for this core. ">cpu_enable_interrupts</a> </dd></dl>

</div>
</div>
<a id="a10055a90cf57a2a22fa9193922f9f2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10055a90cf57a2a22fa9193922f9f2a8">&#9670;&nbsp;</a></span>cpu_enable_interrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_enable_interrupts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupts for this core. </p>
<p>If an interrupt is pending, i.e., it arrived while interrupts were disabled, it will be raised as soon as this call is made.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bios_8h.html#ab2be31ceb56ec6919d4d25fe4b2da0c8" title="Disable interrupts for this core. ">cpu_disable_interrupts</a> </dd></dl>

</div>
</div>
<a id="a719b0f9f8854d21436c96931ba1caf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719b0f9f8854d21436c96931ba1caf59">&#9670;&nbsp;</a></span>cpu_ici()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_ici </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise an ICI interrupt to the given core. </p>
<p>This is a simple way that one core may interrupt another. </p>

</div>
</div>
<a id="a825ac4a4bcf2ef8d3c9bb48d5434c161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825ac4a4bcf2ef8d3c9bb48d5434c161">&#9670;&nbsp;</a></span>cpu_initialize_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_initialize_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a6067c1395a75fc3e17f1ea6353065b54">cpu_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ss_sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ss_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a CPU context for a new thread. </p>
<p>To initialize the context, a stack segment of adequate size must be provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context object to initialize </td></tr>
    <tr><td class="paramname">ss_sp</td><td>the pointer to the beginning of the stack segment </td></tr>
    <tr><td class="paramname">ss_size</td><td>the size of the stack segment </td></tr>
    <tr><td class="paramname">func</td><td>the function to execute in the new context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cf5c5e80f04d98362346e6ec770022d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf5c5e80f04d98362346e6ec770022d">&#9670;&nbsp;</a></span>cpu_interrupt_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_interrupt_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaa">Interrupt</a>&#160;</td>
          <td class="paramname"><em>interrupt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a11aeb47c6c66d331acd12556d0d4aedc">interrupt_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define an interrupt handler for this core. </p>
<p>This function set the interrupt handler of the calling core, for the given interrupt. If <code>handler</code> is NULL, then the interrupt will be ignored by this core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt</td><td>the interrupt to set the handler for </td></tr>
    <tr><td class="paramname">handler</td><td>the handler function to call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bios_8h.html#a11aeb47c6c66d331acd12556d0d4aedc" title="The signature type of interrupt handlers. ">interrupt_handler</a> </dd>
<dd>
<a class="el" href="bios_8h.html#a137af7bce5ff764f5c0aa4550086deaa" title="The interrupts supported by the CPU. ">Interrupt</a> </dd></dl>

</div>
</div>
<a id="a78a3870d56e6867224909cf226c2e90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a3870d56e6867224909cf226c2e90a">&#9670;&nbsp;</a></span>cpu_swap_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_swap_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a6067c1395a75fc3e17f1ea6353065b54">cpu_context_t</a> *&#160;</td>
          <td class="paramname"><em>oldctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a6067c1395a75fc3e17f1ea6353065b54">cpu_context_t</a> *&#160;</td>
          <td class="paramname"><em>newctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch the CPU context. </p>
<p>Save the current context into <code>oldctx</code> and load the contents of <code>newctx</code> into the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldctx</td><td>pointer to the storage for the old context </td></tr>
    <tr><td class="paramname">newctx</td><td>pointer to the new context to be loaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3474751482bc2a9a40597f66fe35f630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3474751482bc2a9a40597f66fe35f630">&#9670;&nbsp;</a></span>vm_boot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vm_boot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a11aeb47c6c66d331acd12556d0d4aedc">interrupt_handler</a>&#160;</td>
          <td class="paramname"><em>bootfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>cores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bios_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>serialno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot a CPU with the given number of cores and boot function. </p>
<p>This function sets up a number of simulated cores, each starting to execute function bootfunc.</p>
<p>The number of cores must be between 1 and MAX_CORES.</p>
<p>Also, this function initializes the simulated peripherals (timers and terminals).</p>
<p>The simulation ends (and this function returns) when (and if) all cores return from bootfunc, in which case the VM shuts down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bootfunc</td><td>The function that each simulated core will execute at boot time. When all cores return from this function, the virtual machine shuts down. </td></tr>
    <tr><td class="paramname">cores</td><td>The number of cores simulated by the virtual machine </td></tr>
    <tr><td class="paramname">serialno</td><td>the number of serial ports connected to terminals that the computer will support. The terminals can be accessed via named pipes (aka FIFOs), which must already exist. See the serial API below for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
