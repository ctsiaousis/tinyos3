<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TinyOS-3: Resource lists</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TinyOS-3
   &#160;<span id="projectnumber">rev.2016</span>
   </div>
   <div id="projectbrief">A multicore Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Resource lists</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple and fast list implementation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structresource__list__node.html">resource_list_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List node.  <a href="structresource__list__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2115e4c199a702aaf36f4571877bf013"><td class="memItemLeft" align="right" valign="top"><a id="ga2115e4c199a702aaf36f4571877bf013"></a>
typedef struct <a class="el" href="structprocess__thread__control__block.html">process_thread_control_block</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PTCB</b></td></tr>
<tr class="separator:ga2115e4c199a702aaf36f4571877bf013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91aaadf0c3f9cef2293a99c69795323f"><td class="memItemLeft" align="right" valign="top"><a id="ga91aaadf0c3f9cef2293a99c69795323f"></a>
typedef struct <a class="el" href="structprocess__control__block.html">process_control_block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga91aaadf0c3f9cef2293a99c69795323f">PCB</a></td></tr>
<tr class="memdesc:ga91aaadf0c3f9cef2293a99c69795323f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration. <br /></td></tr>
<tr class="separator:ga91aaadf0c3f9cef2293a99c69795323f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5eca0c5ec064a81ae9246c7d4f32ef"><td class="memItemLeft" align="right" valign="top"><a id="ga8e5eca0c5ec064a81ae9246c7d4f32ef"></a>
typedef struct <a class="el" href="structthread__control__block.html">thread_control_block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga8e5eca0c5ec064a81ae9246c7d4f32ef">TCB</a></td></tr>
<tr class="memdesc:ga8e5eca0c5ec064a81ae9246c7d4f32ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration. <br /></td></tr>
<tr class="separator:ga8e5eca0c5ec064a81ae9246c7d4f32ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d551eb0caa1296280ea2278b4f1b11"><td class="memItemLeft" align="right" valign="top"><a id="gac3d551eb0caa1296280ea2278b4f1b11"></a>
typedef struct <a class="el" href="structcore__control__block.html">core_control_block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#gac3d551eb0caa1296280ea2278b4f1b11">CCB</a></td></tr>
<tr class="memdesc:gac3d551eb0caa1296280ea2278b4f1b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration. <br /></td></tr>
<tr class="separator:gac3d551eb0caa1296280ea2278b4f1b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4de7b0c72db6219c5a6dda2466181f"><td class="memItemLeft" align="right" valign="top"><a id="ga5b4de7b0c72db6219c5a6dda2466181f"></a>
typedef struct <a class="el" href="structdevice__control__block.html">device_control_block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga5b4de7b0c72db6219c5a6dda2466181f">DCB</a></td></tr>
<tr class="memdesc:ga5b4de7b0c72db6219c5a6dda2466181f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration. <br /></td></tr>
<tr class="separator:ga5b4de7b0c72db6219c5a6dda2466181f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c6c294fa1d8ea73ed270404fe5c17d"><td class="memItemLeft" align="right" valign="top"><a id="ga60c6c294fa1d8ea73ed270404fe5c17d"></a>
typedef struct <a class="el" href="structfile__control__block.html">file_control_block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga60c6c294fa1d8ea73ed270404fe5c17d">FCB</a></td></tr>
<tr class="memdesc:ga60c6c294fa1d8ea73ed270404fe5c17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration. <br /></td></tr>
<tr class="separator:ga60c6c294fa1d8ea73ed270404fe5c17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae2ea9be18d20f0c80a62a2f8e2eed4d"><td class="memItemLeft" align="right" valign="top"><a id="gaae2ea9be18d20f0c80a62a2f8e2eed4d"></a>
typedef struct <a class="el" href="structresource__list__node.html">resource_list_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#gaae2ea9be18d20f0c80a62a2f8e2eed4d">rlnode_ptr</a></td></tr>
<tr class="memdesc:gaae2ea9be18d20f0c80a62a2f8e2eed4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef. <br /></td></tr>
<tr class="separator:gaae2ea9be18d20f0c80a62a2f8e2eed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f6244877f7ce2322c90525217ea6e7a"><td class="memItemLeft" align="right" valign="top"><a id="ga8f6244877f7ce2322c90525217ea6e7a"></a>
typedef struct <a class="el" href="structresource__list__node.html">resource_list_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a></td></tr>
<tr class="memdesc:ga8f6244877f7ce2322c90525217ea6e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">List node. <br /></td></tr>
<tr class="separator:ga8f6244877f7ce2322c90525217ea6e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaccdb4bce65952fede472de20297eb36e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#gaccdb4bce65952fede472de20297eb36e">rlnode_new</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *p)</td></tr>
<tr class="memdesc:gaccdb4bce65952fede472de20297eb36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a node as a singleton ring.  <a href="#gaccdb4bce65952fede472de20297eb36e">More...</a><br /></td></tr>
<tr class="separator:gaccdb4bce65952fede472de20297eb36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga578e6dc256d4f1580bd8500edf374aca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga578e6dc256d4f1580bd8500edf374aca">rlnode_init</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *p, void *ptr)</td></tr>
<tr class="memdesc:ga578e6dc256d4f1580bd8500edf374aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a node as a singleton ring.  <a href="#ga578e6dc256d4f1580bd8500edf374aca">More...</a><br /></td></tr>
<tr class="separator:ga578e6dc256d4f1580bd8500edf374aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c4de39ce6c032dd9fc23c88a883a4b"><td class="memItemLeft" align="right" valign="top"><a id="ga47c4de39ce6c032dd9fc23c88a883a4b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga47c4de39ce6c032dd9fc23c88a883a4b">rlnode_swap</a> (<a class="el" href="group__rlists.html#gaae2ea9be18d20f0c80a62a2f8e2eed4d">rlnode_ptr</a> *p, <a class="el" href="group__rlists.html#gaae2ea9be18d20f0c80a62a2f8e2eed4d">rlnode_ptr</a> *q)</td></tr>
<tr class="memdesc:ga47c4de39ce6c032dd9fc23c88a883a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two pointers to rlnode. <br /></td></tr>
<tr class="separator:ga47c4de39ce6c032dd9fc23c88a883a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04dfecc68239457f673c0a63c254541"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#gac04dfecc68239457f673c0a63c254541">rl_splice</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *a, <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *b)</td></tr>
<tr class="memdesc:gac04dfecc68239457f673c0a63c254541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splice two rlnodes.  <a href="#gac04dfecc68239457f673c0a63c254541">More...</a><br /></td></tr>
<tr class="separator:gac04dfecc68239457f673c0a63c254541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9177b286dcefd1d853aae220a98d3c7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga9177b286dcefd1d853aae220a98d3c7b">rlist_remove</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *a)</td></tr>
<tr class="memdesc:ga9177b286dcefd1d853aae220a98d3c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove node from a ring and turn it into singleton.  <a href="#ga9177b286dcefd1d853aae220a98d3c7b">More...</a><br /></td></tr>
<tr class="separator:ga9177b286dcefd1d853aae220a98d3c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60549214daf0df46bcd1a0d5ba5b661"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#gaf60549214daf0df46bcd1a0d5ba5b661">is_rlist_empty</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *a)</td></tr>
<tr class="memdesc:gaf60549214daf0df46bcd1a0d5ba5b661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a list for emptiness.  <a href="#gaf60549214daf0df46bcd1a0d5ba5b661">More...</a><br /></td></tr>
<tr class="separator:gaf60549214daf0df46bcd1a0d5ba5b661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ab59e50f2007a6bfedb0180a73b06f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga63ab59e50f2007a6bfedb0180a73b06f">rlist_push_front</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *list, <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *node)</td></tr>
<tr class="memdesc:ga63ab59e50f2007a6bfedb0180a73b06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert at the head of a list.  <a href="#ga63ab59e50f2007a6bfedb0180a73b06f">More...</a><br /></td></tr>
<tr class="separator:ga63ab59e50f2007a6bfedb0180a73b06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac454004e8fb74ccd539e7fbd1affa86a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#gac454004e8fb74ccd539e7fbd1affa86a">rlist_push_back</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *list, <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *node)</td></tr>
<tr class="memdesc:gac454004e8fb74ccd539e7fbd1affa86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert at the tail of a list.  <a href="#gac454004e8fb74ccd539e7fbd1affa86a">More...</a><br /></td></tr>
<tr class="separator:gac454004e8fb74ccd539e7fbd1affa86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc2be48f94a7573fb8952356c6ba7d1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga5cc2be48f94a7573fb8952356c6ba7d1">rlist_pop_front</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *list)</td></tr>
<tr class="memdesc:ga5cc2be48f94a7573fb8952356c6ba7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the head of the list.  <a href="#ga5cc2be48f94a7573fb8952356c6ba7d1">More...</a><br /></td></tr>
<tr class="separator:ga5cc2be48f94a7573fb8952356c6ba7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55f998d5871e6e563b4320392995a6c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga55f998d5871e6e563b4320392995a6c5">rlist_pop_back</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *list)</td></tr>
<tr class="memdesc:ga55f998d5871e6e563b4320392995a6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the tail of the list.  <a href="#ga55f998d5871e6e563b4320392995a6c5">More...</a><br /></td></tr>
<tr class="separator:ga55f998d5871e6e563b4320392995a6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107b2689c5811f7dbab8f334812b46d0"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga107b2689c5811f7dbab8f334812b46d0">rlist_len</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *list)</td></tr>
<tr class="memdesc:ga107b2689c5811f7dbab8f334812b46d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of a list.  <a href="#ga107b2689c5811f7dbab8f334812b46d0">More...</a><br /></td></tr>
<tr class="separator:ga107b2689c5811f7dbab8f334812b46d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02a33ca2f63b5dc5e9597a54da32cf4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#gac02a33ca2f63b5dc5e9597a54da32cf4">rlist_equal</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *L1, <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *L2)</td></tr>
<tr class="memdesc:gac02a33ca2f63b5dc5e9597a54da32cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check two lists for equality.  <a href="#gac02a33ca2f63b5dc5e9597a54da32cf4">More...</a><br /></td></tr>
<tr class="separator:gac02a33ca2f63b5dc5e9597a54da32cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f5989d7ec35645d6bbb1c15cd438532"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga7f5989d7ec35645d6bbb1c15cd438532">rlist_append</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *ldest, <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *lsrc)</td></tr>
<tr class="memdesc:ga7f5989d7ec35645d6bbb1c15cd438532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the nodes of a list to another.  <a href="#ga7f5989d7ec35645d6bbb1c15cd438532">More...</a><br /></td></tr>
<tr class="separator:ga7f5989d7ec35645d6bbb1c15cd438532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga906dea2f5a25116f979ba6585266453e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga906dea2f5a25116f979ba6585266453e">rlist_prepend</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *ldest, <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *lsrc)</td></tr>
<tr class="memdesc:ga906dea2f5a25116f979ba6585266453e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend the nodes of a list to another.  <a href="#ga906dea2f5a25116f979ba6585266453e">More...</a><br /></td></tr>
<tr class="separator:ga906dea2f5a25116f979ba6585266453e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3911836f21f2f50b4caa2fa1d8e1f1de"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga3911836f21f2f50b4caa2fa1d8e1f1de">rlist_reverse</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *l)</td></tr>
<tr class="memdesc:ga3911836f21f2f50b4caa2fa1d8e1f1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a ring or list.  <a href="#ga3911836f21f2f50b4caa2fa1d8e1f1de">More...</a><br /></td></tr>
<tr class="separator:ga3911836f21f2f50b4caa2fa1d8e1f1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb3a5edeac9f1d43130528292c47cf6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#gafbb3a5edeac9f1d43130528292c47cf6">rlist_find</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *List, void *key, <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *fail)</td></tr>
<tr class="memdesc:gafbb3a5edeac9f1d43130528292c47cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node by key.  <a href="#gafbb3a5edeac9f1d43130528292c47cf6">More...</a><br /></td></tr>
<tr class="separator:gafbb3a5edeac9f1d43130528292c47cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6016cbc055d242a03d823ebfec422c2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rlists.html#ga6016cbc055d242a03d823ebfec422c2b">rlist_select</a> (<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *Lsrc, <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *Ldest, int(*pred)(<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *))</td></tr>
<tr class="memdesc:ga6016cbc055d242a03d823ebfec422c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move nodes.  <a href="#ga6016cbc055d242a03d823ebfec422c2b">More...</a><br /></td></tr>
<tr class="separator:ga6016cbc055d242a03d823ebfec422c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A simple and fast list implementation. </p>
<h2>Overview </h2>
<p>This data structure is a doubly-linked circular list, whose implementation is based on the splicing operation.</p>
<p>In a circular list, the nodes form a ring. For example if a, b, and c are nodes, a ring may look like </p><pre class="fragment">+--&gt; a --&gt; b --&gt; c --&gt;+
|                     |
+&lt;------&lt;--------&lt;----+
</pre><p> where only the <code>next</code> pointer is drawn. The <code>prev</code> pointer of a node is always the opposite of <code>next</code>, i.e., <code>p-&gt;next-&gt;prev==p-&gt;prev-&gt;next==p</code>. In the following, we shall denote such a ring by [a,b,c]. Note that [b,c,a] and [c,a,b] are describing the same ring as [a,b,c]. A singleton ring has just one node, e.g., [a].</p>
<p>The splicing operation between two rlnodes a and b means simply to swap their <code>next</code> pointers (also adjusting the 'prev' pointers appropriately). Splicing two nodes on different rings, joins the two rings. Splicing two nodes on the same ring, splits the ring. For example, <code>splice(a,c)</code> on ring [a,b,c,d] would create two rings [a,d] and [b,c]. A splice can be reversed by repeating it; continuing the previous example, given rings [a,d] and [b,c], splice(a,c) will create ring [a,b,c,d] again. The precise definition of splice is the following: </p><div class="fragment"><div class="line"><a class="code" href="structresource__list__node.html">rlnode</a>* splice(<a class="code" href="structresource__list__node.html">rlnode</a>* a, <a class="code" href="structresource__list__node.html">rlnode</a>* b) {</div><div class="line">    swap(&amp; a-&gt;<a class="code" href="structresource__list__node.html#a04b1ee9524cd800f14de2925141e3762">next</a>-&gt;<a class="code" href="structresource__list__node.html#a280b77fdcee186bcaade02f76322d183">prev</a>, &amp; b-&gt;<a class="code" href="structresource__list__node.html#a04b1ee9524cd800f14de2925141e3762">next</a>-&gt;<a class="code" href="structresource__list__node.html#a280b77fdcee186bcaade02f76322d183">prev</a>);</div><div class="line">    swap(&amp; a-&gt;<a class="code" href="structresource__list__node.html#a04b1ee9524cd800f14de2925141e3762">next</a>, &amp; b-&gt;<a class="code" href="structresource__list__node.html#a04b1ee9524cd800f14de2925141e3762">next</a>);</div><div class="line">    <span class="keywordflow">return</span> b;</div><div class="line">}</div></div><!-- fragment --><p> In general, <code>splice(a,b)</code> applies the following transformation </p><pre class="fragment">[a, x...]  [b, y...]   ==&gt;   [a, y..., b, x...]
[a, x..., b, y...]     ==&gt;   [a, y...]  [b, x...]
</pre><p>To implement lists, an rlnode object is used as <em>sentinel</em>, that is, it holds no data and is not properly part of the list. If L is the list node, then ring [C, L, A, B] represents the list {A,B,C}. The empty list is represented as [L].</p>
<p>We now show some examples of list operations, implemented by splicing. Suppose that L is a pointer to the sentinel node of a list. Also, suppose that N is (pointer to) a node in a singleton ring [N] Then, the the following operation are implemented as shown (in pseudocode): </p><pre class="fragment">empty(L)              ::  return  L == L-&gt;next
head(L)               ::  return  L-&gt;next
tail(L)               ::  return  L-&gt;prev
push_front(L, N)      ::  splice(L, N)
push_back(L, N)       ::  splice(L-&gt;prev, N)
pop_front(L)          ::  return splice(L, L-&gt;next)
pop_back(L)           ::  return splice(L, L-&gt;prev) 
remove(N)             ::  return splice(N-&gt;prev, N)
insert_after(P, N)    ::  splice(P, N)
insert_before(P, N)   ::  splice(P-&gt;prev, N)
</pre><p>These operations can be used to perform other operations. For example, if L1 and L2 are two lists, then we can append the nodes of L2 to L1 (leaving L2 empty), by the following two operations: </p><pre class="fragment">push_back(L1, L2);
remove(L2);
</pre><p>For more details on the implementation, please read the code of <a class="el" href="util_8h.html">util.h</a>.</p>
<h2>Usage </h2>
<p>Resource lists are mostly useful as storage for lists of resources. The main type is the list node, type <code>rlnode</code>. Each <code>rlnode</code> object must be initialized before use, by calling either <code>rlnode_init</code> or <code>rlnode_new</code>. </p><div class="fragment"><div class="line"><a class="code" href="structthread__control__block.html">TCB</a>* mytcb =...;</div><div class="line"><a class="code" href="structfile__control__block.html">FCB</a>* myfcb =...;</div><div class="line"></div><div class="line"><a class="code" href="structresource__list__node.html">rlnode</a> n1, n2;</div><div class="line"></div><div class="line"><span class="comment">// The following four lines are equivalent </span></div><div class="line"><a class="code" href="group__rlists.html#ga578e6dc256d4f1580bd8500edf374aca">rlnode_init</a>(&amp; n1, mytcb); </div><div class="line"><a class="code" href="group__rlists.html#gaccdb4bce65952fede472de20297eb36e">rlnode_new</a>(&amp; n1)-&gt;tcb = mytcb;</div><div class="line"><a class="code" href="group__rlists.html#ga578e6dc256d4f1580bd8500edf374aca">rlnode_init</a>(&amp; n1, NULL);  n1-&gt;tcb = mytcb;</div><div class="line"><a class="code" href="group__rlists.html#gaccdb4bce65952fede472de20297eb36e">rlnode_new</a>(&amp; n1);  n1-&gt;tcb = mytcb;</div><div class="line"></div><div class="line"></div><div class="line">n1-&gt;fcb = myfcb;</div><div class="line">myfcb = n1-&gt;fcb;</div></div><!-- fragment --><h3>Creating lists</h3>
<p>A list is defined by a sentinel node. For example, </p><div class="fragment"><div class="line"><a class="code" href="structresource__list__node.html">rlnode</a> mylist;  </div><div class="line"><a class="code" href="group__rlists.html#gaccdb4bce65952fede472de20297eb36e">rlnode_new</a>(&amp;mylist);</div></div><!-- fragment --><p> Note that, although we did not store a value into the sentinel node, we actually could do so if desired.</p>
<p>Once a list is created, it needs to be filled with data. There are routines for adding nodes to the head and tail of a list, or in an intermediate location. Also, lists can be compared for equality, have their length taken, checked for emptiness, etc. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__rlists.html#ga63ab59e50f2007a6bfedb0180a73b06f" title="Insert at the head of a list. ">rlist_push_front</a> </dd>
<dd>
<a class="el" href="group__rlists.html#gac454004e8fb74ccd539e7fbd1affa86a" title="Insert at the tail of a list. ">rlist_push_back</a></dd></dl>
<h3>Intrusive lists</h3>
<p>In order to add nodes to a list, we must allocate <code>rlnode</code> objects somewhere in memory. It is absolutely legal to use <code>malloc()</code> for this purpose, but we must add code to free the allocated memory, which can be annoying.</p>
<p>If we wish to store objects of a particular kind however, we can use a different technique: we can store an rlnode pointer inside the object itself. A list built by this trick is called an <em>intrusive list</em>.</p>
<p>For example, suppose we want to maintain a list of TCBs with high priority. </p><div class="fragment"><div class="line"><a class="code" href="structresource__list__node.html">rlnode</a> hi_pri_list;  <a class="code" href="group__rlists.html#gaccdb4bce65952fede472de20297eb36e">rlnode_new</a>(&amp;hi_pri_list);</div><div class="line"></div><div class="line"><span class="keyword">struct </span><a class="code" href="structthread__control__block.html">thread_control_block</a> {</div><div class="line"> .... <span class="comment">// other stuff</span></div><div class="line"> <a class="code" href="structresource__list__node.html">rlnode</a> hi_pri_node;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// initialize the node</span></div><div class="line"><a class="code" href="structthread__control__block.html">TCB</a>* newtcb = ...;</div><div class="line"><a class="code" href="group__rlists.html#ga578e6dc256d4f1580bd8500edf374aca">rlnode_init</a>(&amp; newtcb-&gt;hi_pri_node, newtcb);</div><div class="line"></div><div class="line"><span class="comment">// then, we can just add the node to the list</span></div><div class="line"><a class="code" href="group__rlists.html#gac454004e8fb74ccd539e7fbd1affa86a">rlist_push_back</a>(&amp; hi_pri_list, &amp; newtcb-&gt;hi_pri_node);</div></div><!-- fragment --><p>Because node <code>hi_pri_node</code> is stored inside the object, it is always available. The node can be removed and re-added to this or another list, and memory allocation/deallocation is not an issue. The implementation of tinyos3 uses this idea very extensively, in TCB, PCB and FCB. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf60549214daf0df46bcd1a0d5ba5b661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf60549214daf0df46bcd1a0d5ba5b661">&#9670;&nbsp;</a></span>is_rlist_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int is_rlist_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check a list for emptiness. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the list to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the list is empty, else 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00414">414</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="gac04dfecc68239457f673c0a63c254541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac04dfecc68239457f673c0a63c254541">&#9670;&nbsp;</a></span>rl_splice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a>* rl_splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splice two rlnodes. </p>
<p>The splice operation swaps the <code>next</code> pointers of the two nodes, adjusting the <code>prev</code> pointers appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first node </td></tr>
    <tr><td class="paramname">b</td><td>the second node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second node, <code>b</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00392">392</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ga7f5989d7ec35645d6bbb1c15cd438532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f5989d7ec35645d6bbb1c15cd438532">&#9670;&nbsp;</a></span>rlist_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rlist_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>ldest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>lsrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the nodes of a list to another. </p>
<p>After the append, <code>lsrc</code> becomes empty. The operation is </p><pre class="fragment">[ldest, X...] [lsrc, Y...]  ==&gt; [ldest, X..., Y...]  [lsrc]
</pre> 
<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00504">504</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="gac02a33ca2f63b5dc5e9597a54da32cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac02a33ca2f63b5dc5e9597a54da32cf4">&#9670;&nbsp;</a></span>rlist_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rlist_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>L2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check two lists for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L1</td><td>the first list </td></tr>
    <tr><td class="paramname">L2</td><td>the second list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff two lists are equal, else false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00481">481</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="gafbb3a5edeac9f1d43130528292c47cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbb3a5edeac9f1d43130528292c47cf6">&#9670;&nbsp;</a></span>rlist_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a>* rlist_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>List</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>fail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a node by key. </p>
<p>Search and return the first node whose key is equal to a given key, else return a given node (which may be NULL).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">List</td><td>the list to search </td></tr>
    <tr><td class="paramname">key</td><td>the key to search for in the list </td></tr>
    <tr><td class="paramname">fail</td><td>the node pointer to return on failure </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00549">549</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ga107b2689c5811f7dbab8f334812b46d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga107b2689c5811f7dbab8f334812b46d0">&#9670;&nbsp;</a></span>rlist_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t rlist_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the length of a list. </p>
<p>This function returns the length of a list. </p><dl class="section note"><dt>Note</dt><dd>the cost of this operation is \( O(n) \) </dd></dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00463">463</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ga55f998d5871e6e563b4320392995a6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55f998d5871e6e563b4320392995a6c5">&#9670;&nbsp;</a></span>rlist_pop_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a>* rlist_pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove and return the tail of the list. </p>
<p>This function, applied on a non-empty list, will remove the tail of the list and return in. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00455">455</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ga5cc2be48f94a7573fb8952356c6ba7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc2be48f94a7573fb8952356c6ba7d1">&#9670;&nbsp;</a></span>rlist_pop_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a>* rlist_pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove and return the head of the list. </p>
<p>This function, applied on a non-empty list, will remove the head of the list and return in.</p>
<p>When it is applied to an empty list, the function will return the list itself. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00447">447</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ga906dea2f5a25116f979ba6585266453e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga906dea2f5a25116f979ba6585266453e">&#9670;&nbsp;</a></span>rlist_prepend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rlist_prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>ldest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>lsrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend the nodes of a list to another. </p>
<p>After the append, <code>lsrc</code> becomes empty. The operation is </p><pre class="fragment">[ldest, X...] [lsrc, Y...]  ==&gt; [ldest, Y..., X...]  [lsrc]
</pre> 
<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00518">518</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="gac454004e8fb74ccd539e7fbd1affa86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac454004e8fb74ccd539e7fbd1affa86a">&#9670;&nbsp;</a></span>rlist_push_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rlist_push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert at the tail of a list. </p>
<p>Assuming that <code>node</code> is not in the ring of <code>list</code>, this function inserts the ring of <code>node</code> (often a singleton) at the tail of <code>list</code>.</p>
<p>This function is equivalent to <code>splice</code>(list-&gt;prev,node). </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00436">436</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ga63ab59e50f2007a6bfedb0180a73b06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63ab59e50f2007a6bfedb0180a73b06f">&#9670;&nbsp;</a></span>rlist_push_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rlist_push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert at the head of a list. </p>
<p>Assuming that <code>node</code> is not in the ring of <code>list</code>, this function inserts the ring of <code>node</code> (often a singleton) at the head of <code>list</code>.</p>
<p>This function is equivalent to <code>splice(list,node)</code>. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00425">425</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ga9177b286dcefd1d853aae220a98d3c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9177b286dcefd1d853aae220a98d3c7b">&#9670;&nbsp;</a></span>rlist_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a>* rlist_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove node from a ring and turn it into singleton. </p>
<p>This function will remove <code>a</code> from the ring that contains it. If <code>a</code> is a singleton ring, this function has no effect. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the node to remove from a ring </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed node </dd></dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00407">407</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ga3911836f21f2f50b4caa2fa1d8e1f1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3911836f21f2f50b4caa2fa1d8e1f1de">&#9670;&nbsp;</a></span>rlist_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rlist_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse a ring or list. </p>
<p>This function will reverse the direction of a ring. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00529">529</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ga6016cbc055d242a03d823ebfec422c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6016cbc055d242a03d823ebfec422c2b">&#9670;&nbsp;</a></span>rlist_select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rlist_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>Lsrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>Ldest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(<a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move nodes. </p>
<p>Append all nodes of Lsrc which satisfy pred (that is, pred(...) returns non-zero) to the end of Ldest. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00567">567</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ga578e6dc256d4f1580bd8500edf374aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga578e6dc256d4f1580bd8500edf374aca">&#9670;&nbsp;</a></span>rlnode_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a>* rlnode_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a node as a singleton ring. </p>
<p>This function will initialize the pointers of a node to form a singleton ring, and store the . The node is returned, so that one can write code such as </p><div class="fragment"><div class="line"><a class="code" href="structresource__list__node.html">rlnode</a> n;  <a class="code" href="group__rlists.html#ga63ab59e50f2007a6bfedb0180a73b06f">rlist_push_front</a>(&amp;L, <a class="code" href="group__rlists.html#ga578e6dc256d4f1580bd8500edf374aca">rlnode_init</a>(&amp;n, obj));</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd><code>p!=NULL</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the node to initialize into a singleton </td></tr>
    <tr><td class="paramname">ptr</td><td>the pointer to store as the node key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node itself </dd></dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00366">366</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="gaccdb4bce65952fede472de20297eb36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccdb4bce65952fede472de20297eb36e">&#9670;&nbsp;</a></span>rlnode_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a>* rlnode_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rlists.html#ga8f6244877f7ce2322c90525217ea6e7a">rlnode</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a node as a singleton ring. </p>
<p>This function will initialize the pointers of a node to form a singleton ring. The node is returned, so that one can write code such as </p><div class="fragment"><div class="line"><a class="code" href="structresource__list__node.html">rlnode</a> n;  <a class="code" href="group__rlists.html#gaccdb4bce65952fede472de20297eb36e">rlnode_new</a>(&amp;n)-&gt;num = 3;</div></div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd><code>p!=NULL</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the node to initialize into a singleton </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node itself </dd></dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00345">345</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
