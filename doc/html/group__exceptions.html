<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TinyOS-3: An execption-like library.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TinyOS-3
   &#160;<span id="projectnumber">rev.2016</span>
   </div>
   <div id="projectbrief">A multicore Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">An execption-like library.</div>  </div>
</div><!--header-->
<div class="contents">

<p>An exception-like mechanism for C.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for An execption-like library.:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__exceptions.png" border="0" alt="" usemap="#group____exceptions"/>
<map name="group____exceptions" id="group____exceptions">
<area shape="rect" id="node1" href="group__helpers.html" title="These are some internal helpers, not part of the public API. " alt="" coords="219,5,372,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__helpers"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html">Helpers for exceptions</a></td></tr>
<tr class="memdesc:group__helpers"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are some internal helpers, not part of the public API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexception__handler__frame.html">exception_handler_frame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexception__stack__frame.html">exception_stack_frame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gadf8cc03bd0ede7f3e5aafa57de5016dd"><td class="memItemLeft" align="right" valign="top"><a id="gadf8cc03bd0ede7f3e5aafa57de5016dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__concatenate_tokens</b>(x,  y)&#160;&#160;&#160;x ## y</td></tr>
<tr class="separator:gadf8cc03bd0ede7f3e5aafa57de5016dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d2e02c74b05d3ff3bfa9eb3dcd891e3"><td class="memItemLeft" align="right" valign="top"><a id="ga0d2e02c74b05d3ff3bfa9eb3dcd891e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__conc</b>(z,  w)&#160;&#160;&#160;__concatenate_tokens(z,w)</td></tr>
<tr class="separator:ga0d2e02c74b05d3ff3bfa9eb3dcd891e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga07c60bc46505779b049ce597fe609258"><td class="memItemLeft" align="right" valign="top"><a id="ga07c60bc46505779b049ce597fe609258"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>exception_handler</b>) (int)</td></tr>
<tr class="separator:ga07c60bc46505779b049ce597fe609258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644495f4913e96a83cdf2779fd813974"><td class="memItemLeft" align="right" valign="top"><a id="ga644495f4913e96a83cdf2779fd813974"></a>
typedef struct <a class="el" href="structexception__stack__frame.html">exception_stack_frame</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>exception_context</b></td></tr>
<tr class="separator:ga644495f4913e96a83cdf2779fd813974"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7eda2653ee54e0c95e9d51b8fd873298"><td class="memItemLeft" align="right" valign="top"><a id="ga7eda2653ee54e0c95e9d51b8fd873298"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>raise_exception</b> (<a class="el" href="structexception__stack__frame.html">exception_context</a> context)</td></tr>
<tr class="separator:ga7eda2653ee54e0c95e9d51b8fd873298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5232fee2c414c5ff1ff44dc28c83cf42"><td class="memItemLeft" align="right" valign="top"><a id="ga5232fee2c414c5ff1ff44dc28c83cf42"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exception_unwind</b> (<a class="el" href="structexception__stack__frame.html">exception_context</a> context, int errcode)</td></tr>
<tr class="separator:ga5232fee2c414c5ff1ff44dc28c83cf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0ebd2587ae85b044e1306a026246a27"><td class="memItemLeft" align="right" valign="top"><a id="gad0ebd2587ae85b044e1306a026246a27"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>__exc_push_frame</b> (<a class="el" href="structexception__stack__frame.html">exception_context</a> context, struct <a class="el" href="structexception__stack__frame.html">exception_stack_frame</a> *frame)</td></tr>
<tr class="separator:gad0ebd2587ae85b044e1306a026246a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cfe7a060b16ac1cd9a4432853205dc"><td class="memItemLeft" align="right" valign="top"><a id="ga47cfe7a060b16ac1cd9a4432853205dc"></a>
static struct <a class="el" href="structexception__stack__frame.html">exception_stack_frame</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>__exc_try</b> (<a class="el" href="structexception__stack__frame.html">exception_context</a> context, int errcode)</td></tr>
<tr class="separator:ga47cfe7a060b16ac1cd9a4432853205dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d85149bdb927245ff694068119412df"><td class="memItemLeft" align="right" valign="top"><a id="ga9d85149bdb927245ff694068119412df"></a>
static struct <a class="el" href="structexception__stack__frame.html">exception_stack_frame</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>__exc_exit_try</b> (<a class="el" href="structexception__stack__frame.html">exception_context</a> context)</td></tr>
<tr class="separator:ga9d85149bdb927245ff694068119412df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>An exception-like mechanism for C. </p>
<p>Exceptions are supported by many object-oriented languages, such as Java, C++ and Python, but not by C. This makes programming certain kinds of tasks somewhat complicated. These are tasks that can cause a thread to exit back through several layers of calls. For example, a system call may lead to a stack of nested calls to execute the code of a driver. If processing is to be rolled back to the point of entry to the kernel, all calls in that stack need to propagate the error. This makes coding tedious and error-prone.</p>
<p>In C, there is a standard-library facility that can be used to implement such functionality, available by including <code>&lt;setjmp.h&gt;</code>. The help is in the form of functions <code>setjmp()</code> and <code>longjmp</code> (and their vatiatons). In this library, these standard calls, wrapped by some suitable macros, and using some GNU GCC extensions (nested functions), provide some easy-to-use exception-like programming structures.</p>
<h2>Examples</h2>
<p>Before we describe the details, we show some examples of the library's use.</p>
<p>A try-block is declared as follows: </p><div class="fragment"><div class="line">TRY_WITH(context) {</div><div class="line"></div><div class="line">    ON_ERROR {</div><div class="line">        printf(<span class="stringliteral">&quot;Error in what I was doing\n&quot;</span>);</div><div class="line">        <span class="comment">// After this, execute the finally </span></div><div class="line">    }</div><div class="line"></div><div class="line">    FINALLY(e) {</div><div class="line">        <span class="keywordflow">if</span>(e) </div><div class="line">            printf(<span class="stringliteral">&quot;Continuing after error\n&quot;</span>);         </div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            printf(<span class="stringliteral">&quot;Finished without error\n&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// do something here </span></div><div class="line">    <span class="keywordflow">if</span>(error_happens)</div><div class="line">        raise_exception(context);</div><div class="line"></div><div class="line">    <span class="comment">// or call a function that may call raise_exception()</span></div><div class="line">    do_something_else();</div><div class="line"></div><div class="line">    <span class="comment">// If we leave here, FINALLY will be executed </span></div><div class="line">}</div></div><!-- fragment --><p>For example, one could do the following, to construct a composite resource: </p><div class="fragment"><div class="line">Resource r1, r2, r3;</div><div class="line">TRY_WITH(context) {</div><div class="line">    lock_monitor();</div><div class="line">    FINALLY(e) {</div><div class="line">        unlock_monitor();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// This may raise_exception(...)</span></div><div class="line">    r1 = acquire_resource1();</div><div class="line">    ON_ERROR {</div><div class="line">        release_resource1(r1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// This may raise_exception(...)</span></div><div class="line">    r2 = acquire_resource2(r2);</div><div class="line"></div><div class="line">    ON_ERROR {</div><div class="line">        release_resource2(r2);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// This may raise_exception(...)</span></div><div class="line">    r3 = acquire_resrouce3(r1, r2);</div><div class="line">}</div><div class="line"><span class="keywordflow">return</span> r3;</div></div><!-- fragment --><h2>How it works</h2>
<p>The workings are based on the idea of an <b>exception stack</b>. The elements of this stack are called <b>exception stack frames</b> (ESFs). Each thread should have its own exception stack. When a TRY_WITH(...) block begins, a new ESF is pushed to the stack, and the block starts to execute.</p>
<p>Each ESF has two lists of functions of type @ exception_handler, which is defined as <code>void (*)(int)</code>. The nodes for these lists are <code>struct <a class="el" href="structexception__handler__frame.html">exception_handler_frame</a></code> objects. Initially, the new ESF has empty lists. The first list is the list of <b>catchers</b> and the second is the list of <b>finalizers</b>.</p>
<p>As the TRY-block executes, execution reaches <code>FINALLY()</code> and <code>ON_ERROR</code> blocks. When a <code>FINALLY()</code> block is reached, a new handler is added to the finalizers list. When a <code>ON_ERROR</code> block is reached, a new handler is added to the catchers list.</p>
<p>If execution arrives at the end of the TRY-block, the list of catchers is thrown away and the finalizers are executed (in reverse order, that is, last-in-first-out).</p>
<p>If at some point the function <code>raise_exception()</code> is called, execution jumps back at the TRY-block at the top of the exception stack. There, each catcher is first executed, followed by all the finalizers. At the end, the ESF is popped from the exception stack. Then, if at least one catcher did execute, the exception is considered handled, and execution continues after the TRY-block. If however there was no catcher executed, and the exception stack is non-empty, then <code>raise_exception()</code> is called again, to repeat the process.</p>
<p>An exception stack is defined simply as a pointer to <code>struct <a class="el" href="structexception__stack__frame.html">exception_stack_frame</a></code>. An __exception context__is a pointer to such a pointer, that is, </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structexception__stack__frame.html">exception_stack_frame</a>** <a class="code" href="structexception__stack__frame.html">exception_context</a>;</div></div><!-- fragment --><p> A context needs to be available to our code in two places: when a <code>TRY_WITH(context)</code> block is defined, and when <code>raise_exception(context)</code> is called.</p>
<p>One can simply define a context as a global variable: </p><div class="fragment"><div class="line"><span class="comment">// at top level</span></div><div class="line"><span class="keyword">struct </span>execution_stack_frame* exception_stack = NULL;</div><div class="line"><span class="preprocessor">#define TRY  TRY_WITH(&amp;exception_stack)</span></div><div class="line"><span class="preprocessor">#define RAISE  raise_exception(&amp;exception_stack)</span></div><div class="line"></div><div class="line">TRY {</div><div class="line">    ...</div><div class="line">    RAISE;</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>In a multi-threaded case, it is necessary to declare one context for each thread. This can be done at the TCB, for example.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structthread__control__block.html">TCB</a> {</div><div class="line">    ....</div><div class="line">    <span class="keyword">struct </span>execution_stack_frame* exception_stack = NULL;   </div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#define TRY  TRY_WITH(&amp; CURTHREAD-&gt;exception_stack)</span></div><div class="line"><span class="preprocessor">#define RAISE  raise_exception(&amp; CURTHREAD-&gt;exception_stack)</span></div></div><!-- fragment --><h2>Performance</h2>
<p>Although setting up a TRY-block is relatively cheap (basically, a call to <code>setjmp</code> is done), it is better to avoid calling exception handlers. So, for very critical pieces of code, one could do </p><div class="fragment"><div class="line">TRY {</div><div class="line">    lock_mutex();</div><div class="line">    ON_ERROR {</div><div class="line">        unlock_mutex();</div><div class="line">    }</div><div class="line"></div><div class="line">    ... <span class="comment">// stuff</span></div><div class="line"></div><div class="line">    unlock_mutex();</div><div class="line">}</div></div><!-- fragment --><p> instead of the more convenient </p><div class="fragment"><div class="line">TRY {</div><div class="line">    lock_mutex();</div><div class="line">    FINALLY(e) {</div><div class="line">        unlock_mutex();</div><div class="line">    }</div><div class="line"></div><div class="line">    ... <span class="comment">// stuff    </span></div><div class="line">}</div></div><!-- fragment --><p>The first case is faster, because it avoids a function call, when there is no exception, whereas the second will make a call to the <code>FINALLY</code> block, even without an exception raised. But, remember: <b>premature optimization is the source of all evil</b>.</p>
<h2>Raising from inside an exception handler</h2>
<p>It is perfecly legal and supported to have exceptions raised from inside <code>ON_ERROR</code> or <code>FINALLY</code> blocks (or the functions they call).</p>
<p>What happens in this case is that the exception handler execution is aborted and the processing continues with the next exception handler of the ESF. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
