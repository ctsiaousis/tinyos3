<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TinyOS-3: System calls.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TinyOS-3
   &#160;<span id="projectnumber">rev.2016</span>
   </div>
   <div id="projectbrief">A multicore Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">System calls.</div>  </div>
</div><!--header-->
<div class="contents">

<p>Public kernel API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCondVar.html">CondVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variables.  <a href="structCondVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpipe__s.html">pipe_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of file ids, describing a pipe.  <a href="structpipe__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocinfo.html">procinfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing process-related information for a non-free pid.  <a href="structprocinfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf22d54bd4d558803b5ccbc6eb21f83b2"><td class="memItemLeft" align="right" valign="top"><a id="gaf22d54bd4d558803b5ccbc6eb21f83b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gaf22d54bd4d558803b5ccbc6eb21f83b2">NOPROC</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:gaf22d54bd4d558803b5ccbc6eb21f83b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The invalid PID. <br /></td></tr>
<tr class="separator:gaf22d54bd4d558803b5ccbc6eb21f83b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e32d00bc48471b4db49d481ac228dc"><td class="memItemLeft" align="right" valign="top"><a id="ga63e32d00bc48471b4db49d481ac228dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga63e32d00bc48471b4db49d481ac228dc">MAX_PROC</a>&#160;&#160;&#160;65536</td></tr>
<tr class="memdesc:ga63e32d00bc48471b4db49d481ac228dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of processes. <br /></td></tr>
<tr class="separator:ga63e32d00bc48471b4db49d481ac228dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c697bf9e856897ad75f28190a6f0b68"><td class="memItemLeft" align="right" valign="top"><a id="ga9c697bf9e856897ad75f28190a6f0b68"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga9c697bf9e856897ad75f28190a6f0b68">MAX_FILEID</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ga9c697bf9e856897ad75f28190a6f0b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of open files per process. Only values 0 to MAX_FILEID-1 are legal for file descriptors. <br /></td></tr>
<tr class="separator:ga9c697bf9e856897ad75f28190a6f0b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80bacbaea8dd6aecf216d85d981bcb21"><td class="memItemLeft" align="right" valign="top"><a id="ga80bacbaea8dd6aecf216d85d981bcb21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga80bacbaea8dd6aecf216d85d981bcb21">NOFILE</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:ga80bacbaea8dd6aecf216d85d981bcb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The invalid file id. <br /></td></tr>
<tr class="separator:ga80bacbaea8dd6aecf216d85d981bcb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ccfb785dd0b09ec7091fc213c2f491"><td class="memItemLeft" align="right" valign="top"><a id="ga00ccfb785dd0b09ec7091fc213c2f491"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga00ccfb785dd0b09ec7091fc213c2f491">NOTHREAD</a>&#160;&#160;&#160;((<a class="el" href="group__syscalls.html#gaf67ad1c55e6b2a79bf8a99106380ce01">Tid_t</a>)0)</td></tr>
<tr class="memdesc:ga00ccfb785dd0b09ec7091fc213c2f491"><td class="mdescLeft">&#160;</td><td class="mdescRight">The invalid thread ID. <br /></td></tr>
<tr class="separator:ga00ccfb785dd0b09ec7091fc213c2f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96be0bfc33e7e113099c7546798bec99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga96be0bfc33e7e113099c7546798bec99">MUTEX_INIT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga96be0bfc33e7e113099c7546798bec99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to initialize mutexes.  <a href="#ga96be0bfc33e7e113099c7546798bec99">More...</a><br /></td></tr>
<tr class="separator:ga96be0bfc33e7e113099c7546798bec99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7055a466bff255172e05f6ec82d792"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga6a7055a466bff255172e05f6ec82d792">COND_INIT</a>&#160;&#160;&#160;((<a class="el" href="structCondVar.html">CondVar</a>){ NULL, <a class="el" href="group__syscalls.html#ga96be0bfc33e7e113099c7546798bec99">MUTEX_INIT</a> })</td></tr>
<tr class="memdesc:ga6a7055a466bff255172e05f6ec82d792"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to initialize condition variables.  <a href="#ga6a7055a466bff255172e05f6ec82d792">More...</a><br /></td></tr>
<tr class="separator:ga6a7055a466bff255172e05f6ec82d792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga401e1a60d6381236216b6a130a6685bd"><td class="memItemLeft" align="right" valign="top"><a id="ga401e1a60d6381236216b6a130a6685bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga401e1a60d6381236216b6a130a6685bd">MAX_PORT</a>&#160;&#160;&#160;1023</td></tr>
<tr class="memdesc:ga401e1a60d6381236216b6a130a6685bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">the maximum legal port <br /></td></tr>
<tr class="separator:ga401e1a60d6381236216b6a130a6685bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71912b8841547d43a65ad40d730acd5"><td class="memItemLeft" align="right" valign="top"><a id="gab71912b8841547d43a65ad40d730acd5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gab71912b8841547d43a65ad40d730acd5">NOPORT</a>&#160;&#160;&#160;((<a class="el" href="group__syscalls.html#ga13894e5a2ffd5febb7aeb90e87239d61">port_t</a>)0)</td></tr>
<tr class="memdesc:gab71912b8841547d43a65ad40d730acd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">a null value for a port <br /></td></tr>
<tr class="separator:gab71912b8841547d43a65ad40d730acd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga657ad9e9d81dcca25fb225cf99051e0d"><td class="memItemLeft" align="right" valign="top"><a id="ga657ad9e9d81dcca25fb225cf99051e0d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga657ad9e9d81dcca25fb225cf99051e0d">PROCINFO_MAX_ARGS_SIZE</a>&#160;&#160;&#160;(128)</td></tr>
<tr class="memdesc:ga657ad9e9d81dcca25fb225cf99051e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max. size of args returned by a procinfo structure. <br /></td></tr>
<tr class="separator:ga657ad9e9d81dcca25fb225cf99051e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafac07f3170763932fac97b6eab2c3984"><td class="memItemLeft" align="right" valign="top"><a id="gafac07f3170763932fac97b6eab2c3984"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a></td></tr>
<tr class="memdesc:gafac07f3170763932fac97b6eab2c3984"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a process ID. <br /></td></tr>
<tr class="separator:gafac07f3170763932fac97b6eab2c3984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf412159e5cef839836a5e7b19ee75d1c"><td class="memItemLeft" align="right" valign="top">typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gaf412159e5cef839836a5e7b19ee75d1c">timeout_t</a></td></tr>
<tr class="memdesc:gaf412159e5cef839836a5e7b19ee75d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer type for time intervals.  <a href="#gaf412159e5cef839836a5e7b19ee75d1c">More...</a><br /></td></tr>
<tr class="separator:gaf412159e5cef839836a5e7b19ee75d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5097222c5f0da97d92d4712359abc38f"><td class="memItemLeft" align="right" valign="top"><a id="ga5097222c5f0da97d92d4712359abc38f"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a></td></tr>
<tr class="memdesc:ga5097222c5f0da97d92d4712359abc38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a file ID. <br /></td></tr>
<tr class="separator:ga5097222c5f0da97d92d4712359abc38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67ad1c55e6b2a79bf8a99106380ce01"><td class="memItemLeft" align="right" valign="top"><a id="gaf67ad1c55e6b2a79bf8a99106380ce01"></a>
typedef uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gaf67ad1c55e6b2a79bf8a99106380ce01">Tid_t</a></td></tr>
<tr class="memdesc:gaf67ad1c55e6b2a79bf8a99106380ce01"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a thread ID. <br /></td></tr>
<tr class="separator:gaf67ad1c55e6b2a79bf8a99106380ce01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2ec62cae8e0031fd19fc8b91083ade"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a></td></tr>
<tr class="memdesc:gaef2ec62cae8e0031fd19fc8b91083ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex is used to provide mutual exclusion.  <a href="#gaef2ec62cae8e0031fd19fc8b91083ade">More...</a><br /></td></tr>
<tr class="separator:gaef2ec62cae8e0031fd19fc8b91083ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec3f2f835e105271fbbc00272c0ba984"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gaec3f2f835e105271fbbc00272c0ba984">Task</a>) (int, void *)</td></tr>
<tr class="memdesc:gaec3f2f835e105271fbbc00272c0ba984"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signature for the main function of a process.  <a href="#gaec3f2f835e105271fbbc00272c0ba984">More...</a><br /></td></tr>
<tr class="separator:gaec3f2f835e105271fbbc00272c0ba984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56b5ceaaf7d3ab88b4be7f622314dfb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpipe__s.html">pipe_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gad56b5ceaaf7d3ab88b4be7f622314dfb">pipe_t</a></td></tr>
<tr class="memdesc:gad56b5ceaaf7d3ab88b4be7f622314dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of file ids, describing a pipe.  <a href="#gad56b5ceaaf7d3ab88b4be7f622314dfb">More...</a><br /></td></tr>
<tr class="separator:gad56b5ceaaf7d3ab88b4be7f622314dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13894e5a2ffd5febb7aeb90e87239d61"><td class="memItemLeft" align="right" valign="top">typedef int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga13894e5a2ffd5febb7aeb90e87239d61">port_t</a></td></tr>
<tr class="memdesc:ga13894e5a2ffd5febb7aeb90e87239d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for socket ports.  <a href="#ga13894e5a2ffd5febb7aeb90e87239d61">More...</a><br /></td></tr>
<tr class="separator:ga13894e5a2ffd5febb7aeb90e87239d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9682d9066f643f8d18cff58fd3fb09b9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structprocinfo.html">procinfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga9682d9066f643f8d18cff58fd3fb09b9">procinfo</a></td></tr>
<tr class="memdesc:ga9682d9066f643f8d18cff58fd3fb09b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing process-related information for a non-free pid.  <a href="#ga9682d9066f643f8d18cff58fd3fb09b9">More...</a><br /></td></tr>
<tr class="separator:ga9682d9066f643f8d18cff58fd3fb09b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9eb10a0a72ca3149140272e9344a272b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga9eb10a0a72ca3149140272e9344a272b">shutdown_mode</a> { <a class="el" href="group__syscalls.html#gga9eb10a0a72ca3149140272e9344a272bacbd27e0b4e3d4a02b0d833f919887d2d">SHUTDOWN_READ</a> =1, 
<a class="el" href="group__syscalls.html#gga9eb10a0a72ca3149140272e9344a272ba9a7920b6a1eb57633bb981aa60edbe24">SHUTDOWN_WRITE</a> =2, 
<a class="el" href="group__syscalls.html#gga9eb10a0a72ca3149140272e9344a272bab67e72e17566af8eb432d0f3eba6d44d">SHUTDOWN_BOTH</a> =3
 }<tr class="memdesc:ga9eb10a0a72ca3149140272e9344a272b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket shutdown modes.  <a href="group__syscalls.html#ga9eb10a0a72ca3149140272e9344a272b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga9eb10a0a72ca3149140272e9344a272b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1140be44df71d39edaf6a7262fb763ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga1140be44df71d39edaf6a7262fb763ca">Mutex_Lock</a> (<a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a> *)</td></tr>
<tr class="memdesc:ga1140be44df71d39edaf6a7262fb763ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a mutex.  <a href="#ga1140be44df71d39edaf6a7262fb763ca">More...</a><br /></td></tr>
<tr class="separator:ga1140be44df71d39edaf6a7262fb763ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b98d0315d0931d0c28104c36dd559c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga0b98d0315d0931d0c28104c36dd559c9">Mutex_Unlock</a> (<a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a> *)</td></tr>
<tr class="memdesc:ga0b98d0315d0931d0c28104c36dd559c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a mutex that you locked.  <a href="#ga0b98d0315d0931d0c28104c36dd559c9">More...</a><br /></td></tr>
<tr class="separator:ga0b98d0315d0931d0c28104c36dd559c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga970dca2210b3f2ec8aedab7f542a9bf4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga970dca2210b3f2ec8aedab7f542a9bf4">Cond_Wait</a> (<a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a> *mx, <a class="el" href="structCondVar.html">CondVar</a> *cv)</td></tr>
<tr class="memdesc:ga970dca2210b3f2ec8aedab7f542a9bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable.  <a href="#ga970dca2210b3f2ec8aedab7f542a9bf4">More...</a><br /></td></tr>
<tr class="separator:ga970dca2210b3f2ec8aedab7f542a9bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e955b769339be9ea6a0c1bd4151c48f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga4e955b769339be9ea6a0c1bd4151c48f">Cond_TimedWait</a> (<a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a> *mx, <a class="el" href="structCondVar.html">CondVar</a> *cv, <a class="el" href="group__syscalls.html#gaf412159e5cef839836a5e7b19ee75d1c">timeout_t</a> timeout)</td></tr>
<tr class="memdesc:ga4e955b769339be9ea6a0c1bd4151c48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable.  <a href="#ga4e955b769339be9ea6a0c1bd4151c48f">More...</a><br /></td></tr>
<tr class="separator:ga4e955b769339be9ea6a0c1bd4151c48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f64f8be273d2fe77d7de5f4b81e22d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga43f64f8be273d2fe77d7de5f4b81e22d">Cond_Signal</a> (<a class="el" href="structCondVar.html">CondVar</a> *)</td></tr>
<tr class="memdesc:ga43f64f8be273d2fe77d7de5f4b81e22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a condition variable.  <a href="#ga43f64f8be273d2fe77d7de5f4b81e22d">More...</a><br /></td></tr>
<tr class="separator:ga43f64f8be273d2fe77d7de5f4b81e22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8196aa2a48cad90742f254cc3b8fd351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga8196aa2a48cad90742f254cc3b8fd351">Cond_Broadcast</a> (<a class="el" href="structCondVar.html">CondVar</a> *)</td></tr>
<tr class="memdesc:ga8196aa2a48cad90742f254cc3b8fd351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify all threads waiting at a condition variable.  <a href="#ga8196aa2a48cad90742f254cc3b8fd351">More...</a><br /></td></tr>
<tr class="separator:ga8196aa2a48cad90742f254cc3b8fd351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga737ad30d8105b4b76e3eb102dd016404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga737ad30d8105b4b76e3eb102dd016404">Exec</a> (<a class="el" href="group__syscalls.html#gaec3f2f835e105271fbbc00272c0ba984">Task</a> task, int argl, void *args)</td></tr>
<tr class="memdesc:ga737ad30d8105b4b76e3eb102dd016404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new process.  <a href="#ga737ad30d8105b4b76e3eb102dd016404">More...</a><br /></td></tr>
<tr class="separator:ga737ad30d8105b4b76e3eb102dd016404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed0249344c12ecd4f8d440fc05a360a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gabed0249344c12ecd4f8d440fc05a360a">Exit</a> (int val)</td></tr>
<tr class="memdesc:gabed0249344c12ecd4f8d440fc05a360a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the current process.  <a href="#gabed0249344c12ecd4f8d440fc05a360a">More...</a><br /></td></tr>
<tr class="separator:gabed0249344c12ecd4f8d440fc05a360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37017afba05480740d26b033975fef03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga37017afba05480740d26b033975fef03">WaitChild</a> (<a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a> pid, int *exitval)</td></tr>
<tr class="memdesc:ga37017afba05480740d26b033975fef03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a terminating child.  <a href="#ga37017afba05480740d26b033975fef03">More...</a><br /></td></tr>
<tr class="separator:ga37017afba05480740d26b033975fef03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5106ac1f078c5dde2d6fea3881c1a4fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga5106ac1f078c5dde2d6fea3881c1a4fb">GetPid</a> (void)</td></tr>
<tr class="memdesc:ga5106ac1f078c5dde2d6fea3881c1a4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the PID of the caller.  <a href="#ga5106ac1f078c5dde2d6fea3881c1a4fb">More...</a><br /></td></tr>
<tr class="separator:ga5106ac1f078c5dde2d6fea3881c1a4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ccb3f7c80d85e610206c0e1150657b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga33ccb3f7c80d85e610206c0e1150657b">GetPPid</a> (void)</td></tr>
<tr class="memdesc:ga33ccb3f7c80d85e610206c0e1150657b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the PID of the caller's parent.  <a href="#ga33ccb3f7c80d85e610206c0e1150657b">More...</a><br /></td></tr>
<tr class="separator:ga33ccb3f7c80d85e610206c0e1150657b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284070b5fddcc3653e146e63fcbfe6e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscalls.html#gaf67ad1c55e6b2a79bf8a99106380ce01">Tid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga284070b5fddcc3653e146e63fcbfe6e3">CreateThread</a> (<a class="el" href="group__syscalls.html#gaec3f2f835e105271fbbc00272c0ba984">Task</a> task, int argl, void *args)</td></tr>
<tr class="memdesc:ga284070b5fddcc3653e146e63fcbfe6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread in the current process.  <a href="#ga284070b5fddcc3653e146e63fcbfe6e3">More...</a><br /></td></tr>
<tr class="separator:ga284070b5fddcc3653e146e63fcbfe6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75ffeb50fda6297110a2f07ef94d285c"><td class="memItemLeft" align="right" valign="top"><a id="ga75ffeb50fda6297110a2f07ef94d285c"></a>
<a class="el" href="group__syscalls.html#gaf67ad1c55e6b2a79bf8a99106380ce01">Tid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga75ffeb50fda6297110a2f07ef94d285c">ThreadSelf</a> ()</td></tr>
<tr class="memdesc:ga75ffeb50fda6297110a2f07ef94d285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Tid of the current thread. <br /></td></tr>
<tr class="separator:ga75ffeb50fda6297110a2f07ef94d285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ffbb344eb33487ceef5442846a74be0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga9ffbb344eb33487ceef5442846a74be0">ThreadJoin</a> (<a class="el" href="group__syscalls.html#gaf67ad1c55e6b2a79bf8a99106380ce01">Tid_t</a> tid, int *exitval)</td></tr>
<tr class="memdesc:ga9ffbb344eb33487ceef5442846a74be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join the given thread.  <a href="#ga9ffbb344eb33487ceef5442846a74be0">More...</a><br /></td></tr>
<tr class="separator:ga9ffbb344eb33487ceef5442846a74be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f957d985678728a418ff70a617fab4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga5f957d985678728a418ff70a617fab4d">ThreadDetach</a> (<a class="el" href="group__syscalls.html#gaf67ad1c55e6b2a79bf8a99106380ce01">Tid_t</a> tid)</td></tr>
<tr class="memdesc:ga5f957d985678728a418ff70a617fab4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach the given thread.  <a href="#ga5f957d985678728a418ff70a617fab4d">More...</a><br /></td></tr>
<tr class="separator:ga5f957d985678728a418ff70a617fab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab77e59bf31165db88a22ac8f031b8741"><td class="memItemLeft" align="right" valign="top"><a id="gab77e59bf31165db88a22ac8f031b8741"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gab77e59bf31165db88a22ac8f031b8741">ThreadExit</a> (int exitval)</td></tr>
<tr class="memdesc:gab77e59bf31165db88a22ac8f031b8741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the current thread. <br /></td></tr>
<tr class="separator:gab77e59bf31165db88a22ac8f031b8741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31576e1579c15b6b066038702e6557c7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga31576e1579c15b6b066038702e6557c7">GetTerminalDevices</a> ()</td></tr>
<tr class="memdesc:ga31576e1579c15b6b066038702e6557c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of terminal devices available.  <a href="#ga31576e1579c15b6b066038702e6557c7">More...</a><br /></td></tr>
<tr class="separator:ga31576e1579c15b6b066038702e6557c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea2b586a8dfcfc1e7065e1664a0fb35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga6ea2b586a8dfcfc1e7065e1664a0fb35">OpenTerminal</a> (unsigned int termno)</td></tr>
<tr class="memdesc:ga6ea2b586a8dfcfc1e7065e1664a0fb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a stream on terminal device 'termno'.  <a href="#ga6ea2b586a8dfcfc1e7065e1664a0fb35">More...</a><br /></td></tr>
<tr class="separator:ga6ea2b586a8dfcfc1e7065e1664a0fb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39805b4ae668b715fb43f0f1e6ce8c45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga39805b4ae668b715fb43f0f1e6ce8c45">OpenNull</a> ()</td></tr>
<tr class="memdesc:ga39805b4ae668b715fb43f0f1e6ce8c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a stream on the null device.  <a href="#ga39805b4ae668b715fb43f0f1e6ce8c45">More...</a><br /></td></tr>
<tr class="separator:ga39805b4ae668b715fb43f0f1e6ce8c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e9dc545a789eb45b2d356eabbac3ee3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga3e9dc545a789eb45b2d356eabbac3ee3">Read</a> (<a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> fd, char *buf, unsigned int size)</td></tr>
<tr class="memdesc:ga3e9dc545a789eb45b2d356eabbac3ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from a stream.  <a href="#ga3e9dc545a789eb45b2d356eabbac3ee3">More...</a><br /></td></tr>
<tr class="separator:ga3e9dc545a789eb45b2d356eabbac3ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf046f003fde24f79fb395c250137856c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gaf046f003fde24f79fb395c250137856c">Write</a> (<a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> fd, const char *buf, unsigned int size)</td></tr>
<tr class="memdesc:gaf046f003fde24f79fb395c250137856c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to a stream.  <a href="#gaf046f003fde24f79fb395c250137856c">More...</a><br /></td></tr>
<tr class="separator:gaf046f003fde24f79fb395c250137856c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82187e2e98af053a2ab6cb516e9e7f5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga82187e2e98af053a2ab6cb516e9e7f5a">Close</a> (<a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> fd)</td></tr>
<tr class="memdesc:ga82187e2e98af053a2ab6cb516e9e7f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a file id.  <a href="#ga82187e2e98af053a2ab6cb516e9e7f5a">More...</a><br /></td></tr>
<tr class="separator:ga82187e2e98af053a2ab6cb516e9e7f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc048c60209e2dfb4b5cfc1c3f21aa88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gacc048c60209e2dfb4b5cfc1c3f21aa88">Dup2</a> (<a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> oldfd, <a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> newfd)</td></tr>
<tr class="memdesc:gacc048c60209e2dfb4b5cfc1c3f21aa88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of a stream to a new file ID.  <a href="#gacc048c60209e2dfb4b5cfc1c3f21aa88">More...</a><br /></td></tr>
<tr class="separator:gacc048c60209e2dfb4b5cfc1c3f21aa88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6355ce54e047c31538ed5ed9108b5b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gab6355ce54e047c31538ed5ed9108b5b3">Pipe</a> (<a class="el" href="group__syscalls.html#gad56b5ceaaf7d3ab88b4be7f622314dfb">pipe_t</a> *pipe)</td></tr>
<tr class="memdesc:gab6355ce54e047c31538ed5ed9108b5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a pipe.  <a href="#gab6355ce54e047c31538ed5ed9108b5b3">More...</a><br /></td></tr>
<tr class="separator:gab6355ce54e047c31538ed5ed9108b5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf167321edde68e905173d8056d3eb2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gadf167321edde68e905173d8056d3eb2f">Socket</a> (<a class="el" href="group__syscalls.html#ga13894e5a2ffd5febb7aeb90e87239d61">port_t</a> port)</td></tr>
<tr class="memdesc:gadf167321edde68e905173d8056d3eb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new socket bound on a port.  <a href="#gadf167321edde68e905173d8056d3eb2f">More...</a><br /></td></tr>
<tr class="separator:gadf167321edde68e905173d8056d3eb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff5bae3e7b9e5bbf5a788a5ff739bf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga9ff5bae3e7b9e5bbf5a788a5ff739bf7">Listen</a> (<a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> sock)</td></tr>
<tr class="memdesc:ga9ff5bae3e7b9e5bbf5a788a5ff739bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a socket as a listening socket.  <a href="#ga9ff5bae3e7b9e5bbf5a788a5ff739bf7">More...</a><br /></td></tr>
<tr class="separator:ga9ff5bae3e7b9e5bbf5a788a5ff739bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8116ee944d1b03b6fb2fdba59b57d4a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga8116ee944d1b03b6fb2fdba59b57d4a8">Accept</a> (<a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> lsock)</td></tr>
<tr class="memdesc:ga8116ee944d1b03b6fb2fdba59b57d4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a connection.  <a href="#ga8116ee944d1b03b6fb2fdba59b57d4a8">More...</a><br /></td></tr>
<tr class="separator:ga8116ee944d1b03b6fb2fdba59b57d4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747ceadd43e9a4c72b08fffbadaefbdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga747ceadd43e9a4c72b08fffbadaefbdd">Connect</a> (<a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> sock, <a class="el" href="group__syscalls.html#ga13894e5a2ffd5febb7aeb90e87239d61">port_t</a> port, <a class="el" href="group__syscalls.html#gaf412159e5cef839836a5e7b19ee75d1c">timeout_t</a> timeout)</td></tr>
<tr class="memdesc:ga747ceadd43e9a4c72b08fffbadaefbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection to a listener at a specific port.  <a href="#ga747ceadd43e9a4c72b08fffbadaefbdd">More...</a><br /></td></tr>
<tr class="separator:ga747ceadd43e9a4c72b08fffbadaefbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d49d63d8c0f9fc0917cc1bda6fdfcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga61d49d63d8c0f9fc0917cc1bda6fdfcb">ShutDown</a> (<a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> sock, <a class="el" href="group__syscalls.html#ga9eb10a0a72ca3149140272e9344a272b">shutdown_mode</a> how)</td></tr>
<tr class="memdesc:ga61d49d63d8c0f9fc0917cc1bda6fdfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down one direction of socket communication.  <a href="#ga61d49d63d8c0f9fc0917cc1bda6fdfcb">More...</a><br /></td></tr>
<tr class="separator:ga61d49d63d8c0f9fc0917cc1bda6fdfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf326b11574cdc84a9e21b9d860076821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#gaf326b11574cdc84a9e21b9d860076821">OpenInfo</a> ()</td></tr>
<tr class="memdesc:gaf326b11574cdc84a9e21b9d860076821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a kernel information stream.  <a href="#gaf326b11574cdc84a9e21b9d860076821">More...</a><br /></td></tr>
<tr class="separator:gaf326b11574cdc84a9e21b9d860076821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d9ee7df9665928617a9f9c0cc6d361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls.html#ga31d9ee7df9665928617a9f9c0cc6d361">boot</a> (unsigned int ncores, unsigned int terminals, <a class="el" href="group__syscalls.html#gaec3f2f835e105271fbbc00272c0ba984">Task</a> boot_task, int argl, void *args)</td></tr>
<tr class="memdesc:ga31d9ee7df9665928617a9f9c0cc6d361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot tinyos3.  <a href="#ga31d9ee7df9665928617a9f9c0cc6d361">More...</a><br /></td></tr>
<tr class="separator:ga31d9ee7df9665928617a9f9c0cc6d361"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Public kernel API. </p>
<p>This file contains the system calls offered by TinyOS to the applications. These calls are split into three groups: (a) process control (b) concurrency control and (c) I/O </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga6a7055a466bff255172e05f6ec82d792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a7055a466bff255172e05f6ec82d792">&#9670;&nbsp;</a></span>COND_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COND_INIT&#160;&#160;&#160;((<a class="el" href="structCondVar.html">CondVar</a>){ NULL, <a class="el" href="group__syscalls.html#ga96be0bfc33e7e113099c7546798bec99">MUTEX_INIT</a> })</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is used to initialize condition variables. </p>
<p>It is used as follows: </p><div class="fragment"><div class="line"><a class="code" href="structCondVar.html">CondVar</a> my_cv = <a class="code" href="group__syscalls.html#ga6a7055a466bff255172e05f6ec82d792">COND_INIT</a>;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tinyos_8h_source.html#l00136">136</a> of file <a class="el" href="tinyos_8h_source.html">tinyos.h</a>.</p>

</div>
</div>
<a id="ga96be0bfc33e7e113099c7546798bec99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96be0bfc33e7e113099c7546798bec99">&#9670;&nbsp;</a></span>MUTEX_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MUTEX_INIT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is used to initialize mutexes. </p>
<p>Always initialize a mutex as follows: </p><div class="fragment"><div class="line"><a class="code" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a> my_mutex = <a class="code" href="group__syscalls.html#ga96be0bfc33e7e113099c7546798bec99">MUTEX_INIT</a>;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tinyos_8h_source.html#l00089">89</a> of file <a class="el" href="tinyos_8h_source.html">tinyos.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaef2ec62cae8e0031fd19fc8b91083ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef2ec62cae8e0031fd19fc8b91083ade">&#9670;&nbsp;</a></span>Mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mutex is used to provide mutual exclusion. </p>
<p>Mutexes are used extensively to surround critical sections. The TinyOS mutexes are suitable for use in user-space, as well as in the implementation of the kernel.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#ga1140be44df71d39edaf6a7262fb763ca" title="Lock a mutex. ">Mutex_Lock</a> </dd>
<dd>
<a class="el" href="group__syscalls.html#ga0b98d0315d0931d0c28104c36dd559c9" title="Unlock a mutex that you locked. ">Mutex_Unlock</a> </dd>
<dd>
<a class="el" href="group__syscalls.html#ga96be0bfc33e7e113099c7546798bec99" title="This macro is used to initialize mutexes. ">MUTEX_INIT</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tinyos_8h_source.html#l00079">79</a> of file <a class="el" href="tinyos_8h_source.html">tinyos.h</a>.</p>

</div>
</div>
<a id="gad56b5ceaaf7d3ab88b4be7f622314dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad56b5ceaaf7d3ab88b4be7f622314dfb">&#9670;&nbsp;</a></span>pipe_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structpipe__s.html">pipe_s</a>  <a class="el" href="group__syscalls.html#gad56b5ceaaf7d3ab88b4be7f622314dfb">pipe_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pair of file ids, describing a pipe. </p>
<p>This structure is initialized by the <code><a class="el" href="group__syscalls.html#gab6355ce54e047c31538ed5ed9108b5b3" title="Construct and return a pipe. ">Pipe()</a></code> system call with two file descriptors, for the read and write ends of the pipe respectively. Writing bytes to the write end using <code><a class="el" href="group__syscalls.html#gaf046f003fde24f79fb395c250137856c" title="Write bytes to a stream. ">Write()</a></code> will make them available at the read end, unsing <code><a class="el" href="group__syscalls.html#ga3e9dc545a789eb45b2d356eabbac3ee3" title="Read bytes from a stream. ">Read()</a></code>. </p>

</div>
</div>
<a id="ga13894e5a2ffd5febb7aeb90e87239d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13894e5a2ffd5febb7aeb90e87239d61">&#9670;&nbsp;</a></span>port_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int16_t <a class="el" href="group__syscalls.html#ga13894e5a2ffd5febb7aeb90e87239d61">port_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type for socket ports. </p>
<p>A socket port is an integer between 1 and <code>MAX_PORT</code>. </p>

<p class="definition">Definition at line <a class="el" href="tinyos_8h_source.html#l00545">545</a> of file <a class="el" href="tinyos_8h_source.html">tinyos.h</a>.</p>

</div>
</div>
<a id="ga9682d9066f643f8d18cff58fd3fb09b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9682d9066f643f8d18cff58fd3fb09b9">&#9670;&nbsp;</a></span>procinfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structprocinfo.html">procinfo</a>  <a class="el" href="structprocinfo.html">procinfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A struct containing process-related information for a non-free pid. </p>
<p>This structure is returned by information streams. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#gaf326b11574cdc84a9e21b9d860076821" title="Open a kernel information stream. ">OpenInfo</a> </dd></dl>

</div>
</div>
<a id="gaec3f2f835e105271fbbc00272c0ba984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec3f2f835e105271fbbc00272c0ba984">&#9670;&nbsp;</a></span>Task</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* Task) (int, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The signature for the main function of a process. </p>
<p>New processes are created by calling a starting function, whose signature is Task. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#ga737ad30d8105b4b76e3eb102dd016404" title="Create a new process. ">Exec</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tinyos_8h_source.html#l00216">216</a> of file <a class="el" href="tinyos_8h_source.html">tinyos.h</a>.</p>

</div>
</div>
<a id="gaf412159e5cef839836a5e7b19ee75d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf412159e5cef839836a5e7b19ee75d1c">&#9670;&nbsp;</a></span>timeout_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long <a class="el" href="group__syscalls.html#gaf412159e5cef839836a5e7b19ee75d1c">timeout_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An integer type for time intervals. </p>
<p>The unit is milliseconds. </p>

<p class="definition">Definition at line <a class="el" href="tinyos_8h_source.html#l00036">36</a> of file <a class="el" href="tinyos_8h_source.html">tinyos.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9eb10a0a72ca3149140272e9344a272b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eb10a0a72ca3149140272e9344a272b">&#9670;&nbsp;</a></span>shutdown_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__syscalls.html#ga9eb10a0a72ca3149140272e9344a272b">shutdown_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Socket shutdown modes. </p>
<p>These constants define the legal values for passing the second argument to the <code>ShutDown</code> call.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#ga61d49d63d8c0f9fc0917cc1bda6fdfcb" title="Shut down one direction of socket communication. ">ShutDown</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9eb10a0a72ca3149140272e9344a272bacbd27e0b4e3d4a02b0d833f919887d2d"></a>SHUTDOWN_READ&#160;</td><td class="fielddoc"><p>Shut down the read direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9eb10a0a72ca3149140272e9344a272ba9a7920b6a1eb57633bb981aa60edbe24"></a>SHUTDOWN_WRITE&#160;</td><td class="fielddoc"><p>Shut down the write direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9eb10a0a72ca3149140272e9344a272bab67e72e17566af8eb432d0f3eba6d44d"></a>SHUTDOWN_BOTH&#160;</td><td class="fielddoc"><p>Shut down both directions. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="tinyos_8h_source.html#l00660">660</a> of file <a class="el" href="tinyos_8h_source.html">tinyos.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8116ee944d1b03b6fb2fdba59b57d4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8116ee944d1b03b6fb2fdba59b57d4a8">&#9670;&nbsp;</a></span>Accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> Accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td>
          <td class="paramname"><em>lsock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a connection. </p>
<p>With a listening socket as its sole argument, this call will block waiting for a single <code><a class="el" href="group__syscalls.html#ga747ceadd43e9a4c72b08fffbadaefbdd" title="Create a connection to a listener at a specific port. ">Connect()</a></code> request on the socket's port. one which can be passed as an argument to <code>Accept</code>.</p>
<p>It is possible (and desirable) to re-use the listening socket in multiple successive calls to Accept. This is a typical pattern: a thread blocks at Accept in a tight loop, where each iteration creates new a connection, and then some thread takes over the connection for communication with the client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>the socket to initialize as a listening socket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new socket file id on success, <code>NOFILE</code> on error. Possible reasons for error:<ul>
<li>the file id is not legal</li>
<li>the file id is not initialized by <code><a class="el" href="group__syscalls.html#ga9ff5bae3e7b9e5bbf5a788a5ff739bf7" title="Initialize a socket as a listening socket. ">Listen()</a></code> </li>
<li>the available file ids for the process are exhausted</li>
<li>while waiting, the listening socket <code>lsock</code> was closed</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#ga747ceadd43e9a4c72b08fffbadaefbdd" title="Create a connection to a listener at a specific port. ">Connect</a> </dd>
<dd>
<a class="el" href="group__syscalls.html#ga9ff5bae3e7b9e5bbf5a788a5ff739bf7" title="Initialize a socket as a listening socket. ">Listen</a> </dd></dl>

</div>
</div>
<a id="ga31d9ee7df9665928617a9f9c0cc6d361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d9ee7df9665928617a9f9c0cc6d361">&#9670;&nbsp;</a></span>boot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boot </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ncores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>terminals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaec3f2f835e105271fbbc00272c0ba984">Task</a>&#160;</td>
          <td class="paramname"><em>boot_task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot tinyos3. </p>
<p>The function must initialize the simulated computer with the given number of cpu cores and terminals, initialize tinyos and then execute the initial process using function boot_task with parameters argl and args. The boot_task execution can then create more processes.</p>
<p>When the boot_task process finishes, this call halts and cleans up TinyOS structures and then returns. </p>

<p class="definition">Definition at line <a class="el" href="kernel__init_8c_source.html#l00062">62</a> of file <a class="el" href="kernel__init_8c_source.html">kernel_init.c</a>.</p>

</div>
</div>
<a id="ga82187e2e98af053a2ab6cb516e9e7f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82187e2e98af053a2ab6cb516e9e7f5a">&#9670;&nbsp;</a></span>Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a file id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file ID to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This call returns 0 on success and -1 on failure. Note that it is not an error to call Close on a (valid) file id which is already closed. Possible reasons for failure:<ul>
<li>The file id is invalid.</li>
<li>There was a I/O runtime problem. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8196aa2a48cad90742f254cc3b8fd351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8196aa2a48cad90742f254cc3b8fd351">&#9670;&nbsp;</a></span>Cond_Broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cond_Broadcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCondVar.html">CondVar</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify all threads waiting at a condition variable. </p>
<p>Broadcast wakes up all threads sleeping on this condition variable. The calling thread is not preempted by the awoken threads.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#ga970dca2210b3f2ec8aedab7f542a9bf4" title="Wait on a condition variable. ">Cond_Wait</a> </dd>
<dd>
<a class="el" href="group__syscalls.html#ga43f64f8be273d2fe77d7de5f4b81e22d" title="Signal a condition variable. ">Cond_Signal</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernel__cc_8c_source.html#l00195">195</a> of file <a class="el" href="kernel__cc_8c_source.html">kernel_cc.c</a>.</p>

</div>
</div>
<a id="ga43f64f8be273d2fe77d7de5f4b81e22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43f64f8be273d2fe77d7de5f4b81e22d">&#9670;&nbsp;</a></span>Cond_Signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cond_Signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCondVar.html">CondVar</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a condition variable. </p>
<p>This call wakes up exactly one thread sleeping on this condition variable (if any). Note that the woken thread does not preempt the calling thread; i.e., this is a Mesa-style implementation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#ga970dca2210b3f2ec8aedab7f542a9bf4" title="Wait on a condition variable. ">Cond_Wait</a> </dd>
<dd>
<a class="el" href="group__syscalls.html#ga8196aa2a48cad90742f254cc3b8fd351" title="Notify all threads waiting at a condition variable. ">Cond_Broadcast</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernel__cc_8c_source.html#l00187">187</a> of file <a class="el" href="kernel__cc_8c_source.html">kernel_cc.c</a>.</p>

</div>
</div>
<a id="ga4e955b769339be9ea6a0c1bd4151c48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e955b769339be9ea6a0c1bd4151c48f">&#9670;&nbsp;</a></span>Cond_TimedWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cond_TimedWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a> *&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCondVar.html">CondVar</a> *&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaf412159e5cef839836a5e7b19ee75d1c">timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a condition variable. </p>
<p>This must be called only while we have locked the mutex that is associated with this call. It will put the calling thread to sleep, unlocking the mutex. These operations happen atomically.</p>
<p>When the thread is woken up later, it first re-locks the mutex and then returns. A thread may wake up if,</p><ul>
<li>another thread called <code>Cond_Signal</code> or <code>Cond_Broadcast</code> </li>
<li>the timeout expired</li>
<li>other reasons, not specified</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mx</td><td>The mutex to be unlocked as the thread sleeps. </td></tr>
    <tr><td class="paramname">cv</td><td>The condition variable to sleep on. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time in milliseconds to wait blocked on the condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if this thread was woken up by signal/broadcast, 0 otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#ga43f64f8be273d2fe77d7de5f4b81e22d" title="Signal a condition variable. ">Cond_Signal</a> </dd>
<dd>
<a class="el" href="group__syscalls.html#ga8196aa2a48cad90742f254cc3b8fd351" title="Notify all threads waiting at a condition variable. ">Cond_Broadcast</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernel__cc_8c_source.html#l00180">180</a> of file <a class="el" href="kernel__cc_8c_source.html">kernel_cc.c</a>.</p>

</div>
</div>
<a id="ga970dca2210b3f2ec8aedab7f542a9bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga970dca2210b3f2ec8aedab7f542a9bf4">&#9670;&nbsp;</a></span>Cond_Wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cond_Wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a> *&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCondVar.html">CondVar</a> *&#160;</td>
          <td class="paramname"><em>cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a condition variable. </p>
<p>This must be called only while we have locked the mutex that is associated with this call. It will put the calling thread to sleep, unlocking the mutex. These operations happen atomically.</p>
<p>When the thread is woken up later, it first re-locks the mutex and then returns. A thread may wake up if,</p><ul>
<li>another thread called <code>Cond_Signal</code> or <code>Cond_Broadcast</code> </li>
<li>other reasons, not specified</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mx</td><td>The mutex to be unlocked as the thread sleeps. </td></tr>
    <tr><td class="paramname">cv</td><td>The condition variable to sleep on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if this thread was woken up by signal/broadcast, 0 otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#ga43f64f8be273d2fe77d7de5f4b81e22d" title="Signal a condition variable. ">Cond_Signal</a> </dd>
<dd>
<a class="el" href="group__syscalls.html#ga8196aa2a48cad90742f254cc3b8fd351" title="Notify all threads waiting at a condition variable. ">Cond_Broadcast</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernel__cc_8c_source.html#l00175">175</a> of file <a class="el" href="kernel__cc_8c_source.html">kernel_cc.c</a>.</p>

</div>
</div>
<a id="ga747ceadd43e9a4c72b08fffbadaefbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga747ceadd43e9a4c72b08fffbadaefbdd">&#9670;&nbsp;</a></span>Connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga13894e5a2ffd5febb7aeb90e87239d61">port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaf412159e5cef839836a5e7b19ee75d1c">timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection to a listener at a specific port. </p>
<p>Given a socket <code>sock</code> and <code>port</code>, this call will attempt to establish a connection to a listening socket on that port. If sucessful, the <code>sock</code> stream is connected to the new stream created by the listener.</p>
<p>The two connected sockets communicate by virtue of two pipes of opposite directions, but with one file descriptor servicing both pipes at each end.</p>
<p>The connect call will block for approximately the specified amount of time. The resolution of this timeout is implementation specific, but should be in the order of 100's of msec. Therefore, a timeout of at least 500 msec is reasonable. If a negative timeout is given, it means, "infinite timeout".</p>
<p>sock the socket to connect to the other end  port the port on which to seek a listening socket  timeout the approximate amount of time to wait for a connection. </p><dl class="section return"><dt>Returns</dt><dd>0 on success and -1 on error. Possible reasons for error:<ul>
<li>the file id <code>sock</code> is not legal (i.e., an unconnected, non-listening socket)</li>
<li>the given port is illegal.</li>
<li>the port does not have a listening socket bound to it by <code>Listen</code>.</li>
<li>the timeout has expired without a successful connection. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga284070b5fddcc3653e146e63fcbfe6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga284070b5fddcc3653e146e63fcbfe6e3">&#9670;&nbsp;</a></span>CreateThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscalls.html#gaf67ad1c55e6b2a79bf8a99106380ce01">Tid_t</a> CreateThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaec3f2f835e105271fbbc00272c0ba984">Task</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread in the current process. </p>
<p>The new thread is executed in the same process as the calling thread. If this thread returns from function task, the return value is used as an argument to <code>ThreadExit</code>.</p>
<p>The new thread is created by executing function <code>task</code>, with the arguments of <code>argl</code> and <code>args</code> passed to it. Note that, unlike <code>Exec</code>, where argl and args must define a byte buffer, here there is no such requirement! The two arguments are passed to the new thread verbatim, and can be unrelated. It is the responsibility of the programmer to define their meaning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>a function to execute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc048c60209e2dfb4b5cfc1c3f21aa88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc048c60209e2dfb4b5cfc1c3f21aa88">&#9670;&nbsp;</a></span>Dup2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Dup2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td>
          <td class="paramname"><em>oldfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td>
          <td class="paramname"><em>newfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of a stream to a new file ID. </p>
<p>If <code>newfd</code> is already in use by another file, it is first closed (unless <code>oldfd==newfd</code>, in which case nothing happens).</p>
<p>After the successful call, both oldfd and newfd refer to the same file object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldfd</td><td>the file id to copy from </td></tr>
    <tr><td class="paramname">newfd</td><td>the new file id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This call returns 0 on success and -1 on failure. Possible reasons for failure:<ul>
<li>Either oldfd or newfd is invalid.</li>
<li>oldfd is not an open file. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga737ad30d8105b4b76e3eb102dd016404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga737ad30d8105b4b76e3eb102dd016404">&#9670;&nbsp;</a></span>Exec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a> Exec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaec3f2f835e105271fbbc00272c0ba984">Task</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new process. </p>
<p>This call creates a new process by calling function <code>task</code>, passing it a byte array. The byte array is described by a pair of (int length,void* position), and is a <em>copy</em> of the byte array defined by the (argl, args) pair of arguments to Exec.</p>
<ul>
<li>The new process inherits all file ids of the current process.</li>
<li>The new process is a child of the current process.</li>
<li>The new process is started with a thread executing <code>task</code>. When this thread returns, with an integer value, the process terminates, yielding this exit status.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the main function of the new process </td></tr>
    <tr><td class="paramname">argl</td><td>the length of byte array <code>args</code> </td></tr>
    <tr><td class="paramname">args</td><td>the byte array copied as argument to <code>task</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the pid of the new process is returned. On error, NOPROC is returned. Possible errors:<ul>
<li>The maximum number of processes has been reached. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabed0249344c12ecd4f8d440fc05a360a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed0249344c12ecd4f8d440fc05a360a">&#9670;&nbsp;</a></span>Exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Exit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit the current process. </p>
<p>When this function is called by a process thread, the process terminates and sets its exit code to <code>val</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Alternatively, the process may terminate by returning (with an integer return value) from its main function, in which case the return value of the main function becomes the exit status.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the exit status of the process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#ga737ad30d8105b4b76e3eb102dd016404" title="Create a new process. ">Exec</a> </dd></dl>

</div>
</div>
<a id="ga5106ac1f078c5dde2d6fea3881c1a4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5106ac1f078c5dde2d6fea3881c1a4fb">&#9670;&nbsp;</a></span>GetPid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a> GetPid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the PID of the caller. </p>
<p>This function returns the pid of the current process </p>

</div>
</div>
<a id="ga33ccb3f7c80d85e610206c0e1150657b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33ccb3f7c80d85e610206c0e1150657b">&#9670;&nbsp;</a></span>GetPPid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a> GetPPid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the PID of the caller's parent. </p>
<p>This function returns the pid of the parent of the current process. </p>

</div>
</div>
<a id="ga31576e1579c15b6b066038702e6557c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31576e1579c15b6b066038702e6557c7">&#9670;&nbsp;</a></span>GetTerminalDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GetTerminalDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of terminal devices available. </p>
<p>Terminals are numbered starting from 0. </p>

</div>
</div>
<a id="ga9ff5bae3e7b9e5bbf5a788a5ff739bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ff5bae3e7b9e5bbf5a788a5ff739bf7">&#9670;&nbsp;</a></span>Listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a socket as a listening socket. </p>
<p>A listening socket is one which can be passed as an argument to <code>Accept</code>. Once a socket becomes a listening socket, it is not possible to call any other functions on it except <code>Accept</code>,  and <code><a class="el" href="group__syscalls.html#gacc048c60209e2dfb4b5cfc1c3f21aa88" title="Make a copy of a stream to a new file ID. ">Dup2()</a></code>.</p>
<p>The socket must be bound to a port, as a result of calling <code>Socket</code>. On each port there must be a unique listening socket (although any number of non-listening sockets are allowed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>the socket to initialize as a listening socket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. Possible reasons for error:<ul>
<li>the file id is not legal</li>
<li>the socket is not bound to a port</li>
<li>the port bound to the socket is occupied by another listener</li>
<li>the socket has already been initialized </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#gadf167321edde68e905173d8056d3eb2f" title="Return a new socket bound on a port. ">Socket</a> </dd></dl>

</div>
</div>
<a id="ga1140be44df71d39edaf6a7262fb763ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1140be44df71d39edaf6a7262fb763ca">&#9670;&nbsp;</a></span>Mutex_Lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mutex_Lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a mutex. </p>
<p>Lock a mutex, by waiting if necessary, as long as it takes. In user-space and in kernel-space (preemptive domain), the locking will yield after spinning for a few hundred times. In scheduler space (non-preemptive domain), the mutex lock operation is pure spinlock.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade" title="A mutex is used to provide mutual exclusion. ">Mutex</a> </dd>
<dd>
<a class="el" href="group__syscalls.html#ga0b98d0315d0931d0c28104c36dd559c9" title="Unlock a mutex that you locked. ">Mutex_Unlock</a> </dd>
<dd>
<a class="el" href="kernel__cc_8h.html#a6121802a0b64aae83288f60bf8a76834" title="Set the preemption status for the current thread. ">set_core_preemption</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernel__cc_8c_source.html#l00035">35</a> of file <a class="el" href="kernel__cc_8c_source.html">kernel_cc.c</a>.</p>

</div>
</div>
<a id="ga0b98d0315d0931d0c28104c36dd559c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b98d0315d0931d0c28104c36dd559c9">&#9670;&nbsp;</a></span>Mutex_Unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mutex_Unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade">Mutex</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a mutex that you locked. </p>
<p>This operation is non-blocking. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__syscalls.html#gaef2ec62cae8e0031fd19fc8b91083ade" title="A mutex is used to provide mutual exclusion. ">Mutex</a> </dd>
<dd>
<a class="el" href="group__syscalls.html#ga1140be44df71d39edaf6a7262fb763ca" title="Lock a mutex. ">Mutex_Lock</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernel__cc_8c_source.html#l00056">56</a> of file <a class="el" href="kernel__cc_8c_source.html">kernel_cc.c</a>.</p>

</div>
</div>
<a id="gaf326b11574cdc84a9e21b9d860076821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf326b11574cdc84a9e21b9d860076821">&#9670;&nbsp;</a></span>OpenInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> OpenInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a kernel information stream. </p>
<p>This is a read-only stream that returns a sequence of <code>procinfo</code> structures, each packed into a block of size <code>sizeof(procinfo)</code>.</p>
<p>Each procinfo structure contains information pertaining to some used PCB (active or zombie) during the time of the stream.</p>
<p>There is no guarantee of the timeliness of the information. A best-effort approach to return relevant system information is made.</p>
<dl class="section return"><dt>Returns</dt><dd>a file id on success, or NOFILE on error. Possible reasons for error are:<ul>
<li>the available file ids for the process are exhausted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga39805b4ae668b715fb43f0f1e6ce8c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39805b4ae668b715fb43f0f1e6ce8c45">&#9670;&nbsp;</a></span>OpenNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> OpenNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a stream on the null device. </p>
<p>The null device is a virtual device representing an "infinite" sequence of 0 bytes. Every read on this device returns the requested number of 0s. Also, every write to this device has no effecf.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, OpenNull returns the file id for a new file for this terminal. On error, it returns NOFILE. Possible errors are:<ul>
<li>The maximum number of file descriptors has been reached. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6ea2b586a8dfcfc1e7065e1664a0fb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea2b586a8dfcfc1e7065e1664a0fb35">&#9670;&nbsp;</a></span>OpenTerminal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> OpenTerminal </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>termno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a stream on terminal device 'termno'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">termno</td><td>the terminal number to open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the file ID of the new descriptor On success, OpenTerminal returns the file id for a new file for this terminal. On error, it returns <code>NOFILE</code>. Possible errors are:<ul>
<li>The terminal device does not exist.</li>
<li>The maximum number of file descriptors has been reached. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab6355ce54e047c31538ed5ed9108b5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6355ce54e047c31538ed5ed9108b5b3">&#9670;&nbsp;</a></span>Pipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Pipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gad56b5ceaaf7d3ab88b4be7f622314dfb">pipe_t</a> *&#160;</td>
          <td class="paramname"><em>pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and return a pipe. </p>
<p>A pipe is a one-directional buffer accessed via two file ids, one for each end of the buffer. The size of the buffer is implementation-specific, but can be assumed to be between 4 and 16 kbytes.</p>
<p>Once a pipe is constructed, it remains operational as long as both ends are open. If the read end is closed, the write end becomes unusable: calls on <code>Write</code> to it return error. On the other hand, if the write end is closed, the read end continues to operate until the buffer is empty, at which point calls to <code>Read</code> return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>a pointer to a pipe_t structure for storing the file ids. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 on error. Possible reasons for error:<ul>
<li>the available file ids for the process are exhausted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3e9dc545a789eb45b2d356eabbac3ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e9dc545a789eb45b2d356eabbac3ee3">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from a stream. </p>
<p>The <code>buf</code> and <code>size</code> arguments are, respectively, a buffer into which input data can be placed and the size of that buffer.</p>
<p>As its function result, the <code>Read</code> function should return the number of bytes copied into <code>buf</code>, or <code>-1</code> on error. The call may return fewer bytes than <code>size</code>, but at least 1. A value of 0 indicates "end of file".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file ID of the stream to read from </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to a byte buffer to receive the read data </td></tr>
    <tr><td class="paramname">size</td><td>maximum size of <code>buf</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes copied, 0 if we have reached EOF, or -1, indicating some error. Possible errors are:<ul>
<li>The file descriptor is invalid.</li>
<li>There was a I/O runtime problem. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga61d49d63d8c0f9fc0917cc1bda6fdfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61d49d63d8c0f9fc0917cc1bda6fdfcb">&#9670;&nbsp;</a></span>ShutDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ShutDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga9eb10a0a72ca3149140272e9344a272b">shutdown_mode</a>&#160;</td>
          <td class="paramname"><em>how</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down one direction of socket communication. </p>
<p>With a socket which is connected to another socket, this call will shut down one or the other direction of communication. The shut down of a direction has implications similar to those of a pipe's end shutdown. More specifically, assume that this end is socket A, connected to socket B at the other end. Then,</p>
<ul>
<li>if <code>ShutDown(A, SHUTDOWN_READ)</code> is called, any attempt to call <code>Write(B,...)</code> will fail with a code of -1.</li>
<li>if ShutDown(A, SHUTDOWN_WRITE)<code>is called, any attempt to call</code>Read(B,...)` will first exhaust the buffered data and then will return 0.</li>
<li>if ShutDown(A, SHUTDOWN_BOTH)` is called, it is equivalent to shutting down both read and write.</li>
</ul>
<p>After shutdown of socket A, the corresponding operation <code>Read(A,...)</code> or <code>Write(A,...)</code> will return -1.</p>
<p>Shutting down multiple times is not an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>the file ID of the socket to shut down. </td></tr>
    <tr><td class="paramname">how</td><td>the type of shutdown requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success and -1 on error. Possible reasons for error:<ul>
<li>the file id <code>sock</code> is not legal (a connected socket stream). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadf167321edde68e905173d8056d3eb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf167321edde68e905173d8056d3eb2f">&#9670;&nbsp;</a></span>Socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a> Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga13894e5a2ffd5febb7aeb90e87239d61">port_t</a>&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new socket bound on a port. </p>
<p>This function returns a file descriptor for a new socket object. If the <code>port</code> argument is NOPORT, then the socket will not be bound to a port. Else, the socket will be bound to the specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>the port the new socket will be bound to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a file id for the new socket, or NOFILE on error. Possible reasons for error:<ul>
<li>the port is iilegal</li>
<li>the available file ids for the process are exhausted </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5f957d985678728a418ff70a617fab4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f957d985678728a418ff70a617fab4d">&#9670;&nbsp;</a></span>ThreadDetach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ThreadDetach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaf67ad1c55e6b2a79bf8a99106380ce01">Tid_t</a>&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach the given thread. </p>
<p>This function makes the thread tid a detached thread. A detached thread is not joinable (ThreadJoin returns an error).</p>
<p>Once a thread has exited, it cannot be detached. A thread can detach itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>the tid of the thread to detach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and -1 on error. Possibe errors are:<ul>
<li>there is no thread with the given tid in this process.</li>
<li>the tid corresponds to an exited thread. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9ffbb344eb33487ceef5442846a74be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ffbb344eb33487ceef5442846a74be0">&#9670;&nbsp;</a></span>ThreadJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ThreadJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gaf67ad1c55e6b2a79bf8a99106380ce01">Tid_t</a>&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exitval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join the given thread. </p>
<p>This function will wait for the thread with the given tid to exit, and return its exit status in <code>*exitval</code>. The tid must refer to a legal thread owned by the same process that owns the caller. Also, the thread must be undetached, or an error is returned.</p>
<p>After a call to join succeeds, subsequent calls will fail (unless tid was re-cycled to a new thread).</p>
<p>It is possible that multiple threads try to join the same thread. If these threads block, then all must return the exit status correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>the thread to join </td></tr>
    <tr><td class="paramname">exitval</td><td>a location where to store the exit value of the joined thread. If NULL, the exit status is not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success and -1 on error. Possible errors are:<ul>
<li>there is no thread with the given tid in this process.</li>
<li>the tid corresponds to the current thread.</li>
<li>the tid corresponds to a detached thread. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga37017afba05480740d26b033975fef03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37017afba05480740d26b033975fef03">&#9670;&nbsp;</a></span>WaitChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a> WaitChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#gafac07f3170763932fac97b6eab2c3984">Pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exitval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a terminating child. </p>
<p>This function will return the exit status of a terminated child process, waiting if necessary for a child process to end. When parameter <code>pid</code> holds the value of a specific child process of this process, <code>WaitChild</code> will wait for this specific process to finish. If parameter <code>pid</code> is equal to <code>NOPROC</code>, then <code>WaitChild</code> will wait for any* child process to exit.</p>
<p>If parameter <code>exitval</code> is a not null, the exit code of the child process will be stored in the variable pointed to by status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>the process ID of the child to wait on, or <code>NOPROC</code> to designate waiting for any child. </td></tr>
    <tr><td class="paramname">exitval</td><td>a location whithin which the exit status of the terminates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <code>WaitChild</code> returns the pid of an exited child. On error, WaitChild returns <code>NOPROC</code>. Possible errors are:<ul>
<li>the specified pid is not a valid pid.</li>
<li>the specified process is not a child of this process.</li>
<li>the process has no child processes to wait on (when pid=NOPROC). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf046f003fde24f79fb395c250137856c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf046f003fde24f79fb395c250137856c">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls.html#ga5097222c5f0da97d92d4712359abc38f">Fid_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes to a stream. </p>
<p>The <code>buf</code> and <code>size</code> arguments are, respectively, a buffer into which input data can be placed and the size of that buffer.</p>
<p>As its function result, the <code>Read</code> function should return the number of bytes copied into <code>buf</code>, or <code>-1</code> on error. The call may return fewer bytes than <code>size</code>, but at least 1.</p>
<p>For terminals, the number of bytes copied should be equal to size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file ID of the stream to read from </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to a byte buffer to receive the read data </td></tr>
    <tr><td class="paramname">size</td><td>maximum size of <code>buf</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>As its function result, the <code>Write</code> function should return the number of bytes copied from <code>buf</code>, or -1 on error. Possible errors are:<ul>
<li>The file id is invalid.</li>
<li>There was a I/O runtime problem. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
