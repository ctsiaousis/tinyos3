\hypertarget{kernel__cc_8c}{}\section{kernel\+\_\+cc.\+c File Reference}
\label{kernel__cc_8c}\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}


The implementation for concurrency control .  


{\ttfamily \#include $<$assert.\+h$>$}\newline
{\ttfamily \#include \char`\"{}kernel\+\_\+sched.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}kernel\+\_\+proc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}kernel\+\_\+cc.\+h\char`\"{}}\newline
Include dependency graph for kernel\+\_\+cc.\+c\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{kernel__cc_8c__incl}
\end{center}
\end{figure}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{kernel__cc_8c_a146046d778f29cb1d176fcbd4d066733}\label{kernel__cc_8c_a146046d778f29cb1d176fcbd4d066733}} 
\#define {\bfseries M\+U\+T\+E\+X\+\_\+\+S\+P\+I\+NS}~1000
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group__syscalls_ga1140be44df71d39edaf6a7262fb763ca}{Mutex\+\_\+\+Lock} (\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} $\ast$lock)
\begin{DoxyCompactList}\small\item\em Lock a mutex. \end{DoxyCompactList}\item 
void \hyperlink{group__syscalls_ga0b98d0315d0931d0c28104c36dd559c9}{Mutex\+\_\+\+Unlock} (\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} $\ast$lock)
\begin{DoxyCompactList}\small\item\em Unlock a mutex that you locked. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{kernel__cc_8c_abc2cf733db2b12d13a3f6e258f89dd2b}\label{kernel__cc_8c_abc2cf733db2b12d13a3f6e258f89dd2b}} 
static void {\bfseries remove\+\_\+from\+\_\+ring} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv, \+\_\+\+\_\+cv\+\_\+waiter $\ast$w)
\item 
\mbox{\Hypertarget{kernel__cc_8c_a639afd8d38fd525e27bf8bb1fadf24ee}\label{kernel__cc_8c_a639afd8d38fd525e27bf8bb1fadf24ee}} 
static int {\bfseries cv\+\_\+wait} (\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} $\ast$mutex, \hyperlink{structCondVar}{Cond\+Var} $\ast$cv, enum \hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE} cause, \hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration} timeout)
\item 
\mbox{\Hypertarget{kernel__cc_8c_a57708cb3ca29d1a575df0af638ca7d8d}\label{kernel__cc_8c_a57708cb3ca29d1a575df0af638ca7d8d}} 
static void {\bfseries cv\+\_\+signal} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv)
\item 
int \hyperlink{group__syscalls_ga970dca2210b3f2ec8aedab7f542a9bf4}{Cond\+\_\+\+Wait} (\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} $\ast$mutex, \hyperlink{structCondVar}{Cond\+Var} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Wait on a condition variable. \end{DoxyCompactList}\item 
int \hyperlink{group__syscalls_ga4e955b769339be9ea6a0c1bd4151c48f}{Cond\+\_\+\+Timed\+Wait} (\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} $\ast$mutex, \hyperlink{structCondVar}{Cond\+Var} $\ast$cv, \hyperlink{group__syscalls_gaf412159e5cef839836a5e7b19ee75d1c}{timeout\+\_\+t} timeout)
\begin{DoxyCompactList}\small\item\em Wait on a condition variable. \end{DoxyCompactList}\item 
void \hyperlink{group__syscalls_ga43f64f8be273d2fe77d7de5f4b81e22d}{Cond\+\_\+\+Signal} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Signal a condition variable. \end{DoxyCompactList}\item 
void \hyperlink{group__syscalls_ga8196aa2a48cad90742f254cc3b8fd351}{Cond\+\_\+\+Broadcast} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Notify all threads waiting at a condition variable. \end{DoxyCompactList}\item 
int \hyperlink{kernel__cc_8c_a6121802a0b64aae83288f60bf8a76834}{set\+\_\+core\+\_\+preemption} (int preempt)
\begin{DoxyCompactList}\small\item\em Set the preemption status for the current thread. \end{DoxyCompactList}\item 
int \hyperlink{kernel__cc_8c_ac3fd575c0f82fd75f8e7305be1107e2c}{get\+\_\+core\+\_\+preemption} ()
\begin{DoxyCompactList}\small\item\em Get the current preemption status. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{kernel__cc_8c_a64cbb83e8857ffaf703722363ac94f05}\label{kernel__cc_8c_a64cbb83e8857ffaf703722363ac94f05}} 
void \hyperlink{kernel__cc_8c_a64cbb83e8857ffaf703722363ac94f05}{kernel\+\_\+lock} ()
\begin{DoxyCompactList}\small\item\em Lock the kernel. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{kernel__cc_8c_a8ca062a9a1c570f34398bd177cb96e58}\label{kernel__cc_8c_a8ca062a9a1c570f34398bd177cb96e58}} 
void \hyperlink{kernel__cc_8c_a8ca062a9a1c570f34398bd177cb96e58}{kernel\+\_\+unlock} ()
\begin{DoxyCompactList}\small\item\em Unlock the kernel. \end{DoxyCompactList}\item 
int \hyperlink{kernel__cc_8c_a1fad5a21e5010939e1e0ad711192bc6c}{kernel\+\_\+wait\+\_\+wchan} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv, enum \hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE} cause, const char $\ast$wchan\+\_\+name, \hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration} timeout)
\begin{DoxyCompactList}\small\item\em Wait on a condition variable using the kernel lock. \end{DoxyCompactList}\item 
void \hyperlink{kernel__cc_8c_a167cdb3f2a2285becf553405210eb08a}{kernel\+\_\+signal} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Signal a kernel condition to one waiter. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{kernel__cc_8c_a6ab8c1febc779de0c176d4e8a101ec5b}\label{kernel__cc_8c_a6ab8c1febc779de0c176d4e8a101ec5b}} 
void \hyperlink{kernel__cc_8c_a6ab8c1febc779de0c176d4e8a101ec5b}{kernel\+\_\+broadcast} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Signal a kernel condition to all waiters. \end{DoxyCompactList}\item 
void \hyperlink{kernel__cc_8c_aeafd158aa175ab53b85bc55dc4bbd962}{kernel\+\_\+sleep} (\hyperlink{group__scheduler_ga6c969c169777f82c104cf73e501df70f}{Thread\+\_\+state} newstate, enum \hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE} cause)
\begin{DoxyCompactList}\small\item\em Put thread to sleep, unlocking the kernel. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} \hyperlink{kernel__cc_8c_a57ffb2dcd44b56da47dc03b2f85d9480}{kernel\+\_\+mutex} = \hyperlink{group__syscalls_ga96be0bfc33e7e113099c7546798bec99}{M\+U\+T\+E\+X\+\_\+\+I\+N\+IT}
\begin{DoxyCompactList}\small\item\em The kernel lock. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{kernel__cc_8c_a1c9aaa217ee98e133a7d199b5e0049f3}\label{kernel__cc_8c_a1c9aaa217ee98e133a7d199b5e0049f3}} 
static int {\bfseries kernel\+\_\+sem} = 1
\item 
\mbox{\Hypertarget{kernel__cc_8c_addaf45de2e9f92b9eb5ed68cc1017e6f}\label{kernel__cc_8c_addaf45de2e9f92b9eb5ed68cc1017e6f}} 
static \hyperlink{structCondVar}{Cond\+Var} {\bfseries kernel\+\_\+sem\+\_\+cv} = \hyperlink{group__syscalls_ga6a7055a466bff255172e05f6ec82d792}{C\+O\+N\+D\+\_\+\+I\+N\+IT}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
The implementation for concurrency control . 

Locks for scheduler and device drivers. Because we support multiple cores, we need to avoid race conditions with an interrupt handler on the same core, and also to avoid race conditions between cores. 

\subsection{Function Documentation}
\mbox{\Hypertarget{kernel__cc_8c_ac3fd575c0f82fd75f8e7305be1107e2c}\label{kernel__cc_8c_ac3fd575c0f82fd75f8e7305be1107e2c}} 
\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!get\+\_\+core\+\_\+preemption@{get\+\_\+core\+\_\+preemption}}
\index{get\+\_\+core\+\_\+preemption@{get\+\_\+core\+\_\+preemption}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection{\texorpdfstring{get\+\_\+core\+\_\+preemption()}{get\_core\_preemption()}}
{\footnotesize\ttfamily int get\+\_\+core\+\_\+preemption (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the current preemption status. 

\begin{DoxyReturn}{Returns}
the current preemption status for this core, 0 means no preemption and 1 means preemption. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{kernel__cc_8h_a6121802a0b64aae83288f60bf8a76834}{set\+\_\+core\+\_\+preemption} 
\end{DoxySeeAlso}


Definition at line 225 of file kernel\+\_\+cc.\+c.

\mbox{\Hypertarget{kernel__cc_8c_a167cdb3f2a2285becf553405210eb08a}\label{kernel__cc_8c_a167cdb3f2a2285becf553405210eb08a}} 
\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!kernel\+\_\+signal@{kernel\+\_\+signal}}
\index{kernel\+\_\+signal@{kernel\+\_\+signal}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection{\texorpdfstring{kernel\+\_\+signal()}{kernel\_signal()}}
{\footnotesize\ttfamily void kernel\+\_\+signal (\begin{DoxyParamCaption}\item[{\hyperlink{structCondVar}{Cond\+Var} $\ast$}]{cv }\end{DoxyParamCaption})}



Signal a kernel condition to one waiter. 

This call must be made 

Definition at line 295 of file kernel\+\_\+cc.\+c.

\mbox{\Hypertarget{kernel__cc_8c_aeafd158aa175ab53b85bc55dc4bbd962}\label{kernel__cc_8c_aeafd158aa175ab53b85bc55dc4bbd962}} 
\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!kernel\+\_\+sleep@{kernel\+\_\+sleep}}
\index{kernel\+\_\+sleep@{kernel\+\_\+sleep}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection{\texorpdfstring{kernel\+\_\+sleep()}{kernel\_sleep()}}
{\footnotesize\ttfamily void kernel\+\_\+sleep (\begin{DoxyParamCaption}\item[{\hyperlink{group__scheduler_ga6c969c169777f82c104cf73e501df70f}{Thread\+\_\+state}}]{state,  }\item[{enum \hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE}}]{cause }\end{DoxyParamCaption})}



Put thread to sleep, unlocking the kernel. 

System calls should call this function instead of {\ttfamily sleep\+\_\+releasing}, as the kernel lock is not a mutex. 

Definition at line 305 of file kernel\+\_\+cc.\+c.

\mbox{\Hypertarget{kernel__cc_8c_a1fad5a21e5010939e1e0ad711192bc6c}\label{kernel__cc_8c_a1fad5a21e5010939e1e0ad711192bc6c}} 
\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!kernel\+\_\+wait\+\_\+wchan@{kernel\+\_\+wait\+\_\+wchan}}
\index{kernel\+\_\+wait\+\_\+wchan@{kernel\+\_\+wait\+\_\+wchan}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection{\texorpdfstring{kernel\+\_\+wait\+\_\+wchan()}{kernel\_wait\_wchan()}}
{\footnotesize\ttfamily int kernel\+\_\+wait\+\_\+wchan (\begin{DoxyParamCaption}\item[{\hyperlink{structCondVar}{Cond\+Var} $\ast$}]{cv,  }\item[{enum \hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE}}]{cause,  }\item[{const char $\ast$}]{wchan,  }\item[{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}}]{timeout }\end{DoxyParamCaption})}



Wait on a condition variable using the kernel lock. 

\begin{DoxyReturn}{Returns}
1 if signalled, 0 if not 
\end{DoxyReturn}


Definition at line 276 of file kernel\+\_\+cc.\+c.

\mbox{\Hypertarget{kernel__cc_8c_a6121802a0b64aae83288f60bf8a76834}\label{kernel__cc_8c_a6121802a0b64aae83288f60bf8a76834}} 
\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!set\+\_\+core\+\_\+preemption@{set\+\_\+core\+\_\+preemption}}
\index{set\+\_\+core\+\_\+preemption@{set\+\_\+core\+\_\+preemption}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection{\texorpdfstring{set\+\_\+core\+\_\+preemption()}{set\_core\_preemption()}}
{\footnotesize\ttfamily int set\+\_\+core\+\_\+preemption (\begin{DoxyParamCaption}\item[{int}]{preempt }\end{DoxyParamCaption})}



Set the preemption status for the current thread. 

Depending on the value of the argument, this function will set preemption on or off. Preemption is disabled by disabling interrupts. This function is usually called via the convenience macros {\ttfamily preempt\+\_\+on} and {\ttfamily preempt\+\_\+off}. A typical non-\/preemptive section is declared as 
\begin{DoxyCode}
\textcolor{keywordtype}{int} preempt = \hyperlink{kernel__cc_8h_af936bcf607a61848cfea21c119f30905}{preempt\_off};
..
    \textcolor{comment}{// do stuff without preemption }
...
if(preempt) \hyperlink{kernel__cc_8h_ac8efed506a60c7c6f02514e878a4004b}{preempt\_on};
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em preempt} & the new preemption status \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the previous preemption status, where 0 means that preemption was previously off, and 1 means that it was on.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{kernel__cc_8h_af936bcf607a61848cfea21c119f30905}{preempt\+\_\+off} 

\hyperlink{kernel__cc_8h_ac8efed506a60c7c6f02514e878a4004b}{preempt\+\_\+on} 
\end{DoxySeeAlso}


Definition at line 209 of file kernel\+\_\+cc.\+c.



\subsection{Variable Documentation}
\mbox{\Hypertarget{kernel__cc_8c_a57ffb2dcd44b56da47dc03b2f85d9480}\label{kernel__cc_8c_a57ffb2dcd44b56da47dc03b2f85d9480}} 
\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!kernel\+\_\+mutex@{kernel\+\_\+mutex}}
\index{kernel\+\_\+mutex@{kernel\+\_\+mutex}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection{\texorpdfstring{kernel\+\_\+mutex}{kernel\_mutex}}
{\footnotesize\ttfamily \hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} kernel\+\_\+mutex = \hyperlink{group__syscalls_ga96be0bfc33e7e113099c7546798bec99}{M\+U\+T\+E\+X\+\_\+\+I\+N\+IT}\hspace{0.3cm}{\ttfamily [static]}}



The kernel lock. 

Kernel locking is provided by a semaphore, implemented as a monitor. A semaphre for kernel locking has advantages over a simple mutex. The main advantage is that {\ttfamily kernel\+\_\+mutex} is held for a very short time regardless of contention. Thus, in multicore machines, it allows for cores to be passed to other threads. 

Definition at line 250 of file kernel\+\_\+cc.\+c.

